{
  "metadata": {
    "key": "search:general:4:Vue performance benchmarks",
    "created": 1770092620.6218119,
    "ttl": 86400
  },
  "data": [
    {
      "url": "https://madewithvuejs.com/blog/advanced-vue-performance-monitoring",
      "title": "Advanced Vue.js Performance Monitoring",
      "snippet": "To create your first performance budget, identify core pages like the start page, important landing pages, your app dashboard, shopping cart, product pages etc.\n\nThen you can try these strategies:\n\n Approach recommended values / benchmarks for your metrics (see e.g. the recommended thresholds for the Core Web Vitals)\n Measure your status quo and aim for a 20% better result\n Measure your competitors and aim for a 20% better result\n\nIf you haven't measured anything before, it's usually no problem to optimize for 20% better results (see basic strategies in our Vue.js Performance Guide). Then try to stay within this budget over time!\n\n### Do I need a performance budget as a Vue developer? [...] Lighthouse performance score: One super simple value that combines important (user-centric) metrics and works as a high-level summary for us.\n TTFB ‚Äì Time To First Byte: This metric measures how long it takes a user to receive the first byte of our content. It helps us identify issues with slow server response times.\n LCP ‚Äì Largest Contentful Paint: This metric is part of the Core Web Vitals. It describes when the largest block of content is visible to users. It‚Äôs an important milestone in perceived performance. [...] ### üî¢ Quantity-based performance metrics\n\nAnother group of metrics includes all things you can count directly: Your bundle size, or the number of requests.\n\nPros:\n\n These metrics can quickly alert you of specific issues (e.g. uncompressed images, or heavy-weight third-party packages) - super actionable\n\nCons:\n\n Most of these metrics are only theoretically connected to your real user‚Äôs experience\n\n### üôã User-centric performance metrics\n\nThe third group of metrics show the perceived performance of a site, measuring load speed, responsiveness and smoothness.\n\nImportant metrics include for example the Largest Contentful Paint, First Input Delay and Cumulative Layout Shift, which you might know as Google's Web Vitals.\n\nPros:"
    },
    {
      "url": "https://vuejs.org/v2/guide/comparison.html",
      "title": "Comparison with Other Frameworks - Vue.js",
      "snippet": "### Runtime Performance\n\nBoth React and Vue are exceptionally and similarly fast, so speed is unlikely to be a deciding factor in choosing between them. For specific metrics though, check out this 3rd party benchmark, which focuses on raw render/update performance with very simple component trees.\n\n#### Optimization Efforts [...] ### Runtime Performance\n\nBoth frameworks are exceptionally fast, with very similar metrics on benchmarks. You can browse specific metrics for a more granular comparison, but speed is unlikely to be a deciding factor.\n\n### Size\n\nRecent versions of Angular, with AOT compilation and tree-shaking, have been able to get its size down considerably. However, a full-featured Vue 2 project with Vuex + Vue Router included (~30KB gzipped) is still significantly lighter than an out-of-the-box, AOT-compiled application generated by `angular-cli` (~65KB gzipped).\n\n`angular-cli`\n\n### Flexibility [...] ### Runtime Performance\n\nVue has better performance and is much, much easier to optimize because it doesn‚Äôt use dirty checking. AngularJS becomes slow when there are a lot of watchers, because every time anything in the scope changes, all these watchers need to be re-evaluated again. Also, the digest cycle may have to run multiple times to ‚Äústabilize‚Äù if some watcher triggers another update. AngularJS users often have to resort to esoteric techniques to get around the digest cycle, and in some situations, there‚Äôs no way to optimize a scope with many watchers.\n\nVue doesn‚Äôt suffer from this at all because it uses a transparent dependency-tracking observation system with async queueing - all changes trigger independently unless they have explicit dependency relationships."
    },
    {
      "url": "https://www.debugbear.com/blog/vue-devtools-performance",
      "title": "How To Use Vue DevTools To Investigate Performance - DebugBear",
      "snippet": "## Using Vue DevTools to measure performance‚Äã\n\nVue Devtools includes powerful features for analyzing and optimizing the performance of Vue.js applications. These tools help developers identify bottlenecks, measure rendering times, and debug performance-related issues, ensuring smooth and efficient applications.\n\nThe best place to start measuring performance in your Vue app with the usage of Vue Devtools is actually the Timeline tab that can be found in the navigation tab on the left side as shown below:\n\nTo enable performance monitoring, we need to enable it so that the Performance section will be highlighted. Press `Start recording` as shown below: [...] Vue Devtools helps developers investigate performance bottlenecks in Vue applications by the usage of features like live editing, time travel debugging and component inspection. If we add to it additional features like Assets and Vite inspections we receive a powerful tool to help us measure and improve performance of Vue applications continuously.\n\n## Monitor the performance of your Vue app‚Äã\n\nDebugBear provides comprehensive performance monitoring for web applications with both synthetic testing and real user monitoring. Track Core Web Vitals metrics like Largest Contentful Paint and Interaction to Next Paint to ensure your Vue app performs well for all visitors. [...] To best utilize Vue Devtools for performance monitoring, make sure to integrate performance checks into the development phase to avoid issues later on in production. There are a few performance improvements that we can implement based on insights from Vue Devtools:\n\n1. Preventing static content from unneeded re-rendering with the usage of `v-once` directive.\n2. Ensuring that components re-render only when their props or state changes.\n3. If your app has large nested trees of dependencies, focus on optimizing the component hierarchy to reduce updates with usage of `shallowRef`\n4. Deferring loading unneeded components with the use of dynamically loaded (lazy/async) components.\n5. Caching computed properties or calculations with the use of memoization."
    },
    {
      "url": "https://vuejs.org/guide/best-practices/performance",
      "title": "Performance | Vue.js",
      "snippet": "Page Load Performance: how fast the application shows content and becomes interactive on the initial visit. This is usually measured using web vital metrics like Largest Contentful Paint (LCP) and Interaction to Next Paint.\n Update Performance: how fast the application updates in response to user input. For example, how fast a list updates when the user types in a search box, or how fast the page switches when the user clicks a navigation link in a Single-Page Application (SPA)."
    }
  ]
}