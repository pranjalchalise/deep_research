{
  "metadata": {
    "key": "page:https://community.intersystems.com/post/building-ai-agents-zero-hero",
    "created": 1769980464.662244,
    "ttl": 604800
  },
  "data": "Article Henry Pereira · Jun 11, 2025 15m read Open Exchange Building AI Agents: From Zero to Hero #Framework #Python #Tools #Vector Search #InterSystems IRIS Learn how to design scalable, autonomous AI agents that combine reasoning, vector search, and tool integration using LangGraph. Too Long; Didn't Read AI Agents are proactive systems that combine memory, context, and initiative to automate tasks beyond simple chatbots. LangGraph is a framework that enables us to build complex AI workflows, utilizing nodes (tasks) and edges (connections) with built-in state management. This guide will walk you through building an AI-powered customer support agent that classifies priorities, identifies relevant topics, and determines whether to escalate or auto-reply. So, What Exactly Are AI Agents? Let’s face it — “AI agents” can sound like the robots that will take over your boardroom. In reality, they are your proactive sidekicks that can streamline complex workflows and eliminate repetitive tasks. Think of them as the next evolutionary step beyond chatbots: they do not just simply wait for prompts; they initiate actions , coordinate multiple steps, and adapt as they go. Back in the day, crafting a “smart” system meant juggling separate models for language understanding, code generation, data lookup, you name it, and then duct-taping them together. Half of your time used to vanish in integration hell, whereas the other half you spent debugging the glue. Agents flip that script. They bundle context, initiative, and adaptability into a single orchestrated flow. It is not just automation; it is intelligence with a mission. And thanks to such frameworks as LangGraph , assembling an agent squad of your own can actually be… dare I say, fun? What Is LangGraph, Exactly? LangGraph is an innovative framework that revolutionizes the way we build complex applications involving Large Language Models (LLMs). Imagine that you are conducting an orchestra: every instrument (or “node”) needs to know when to play, how loud, and in what sequence. LangGraph, in this case , is your baton, giving you the following: Graph Structure : It employs a graph-like structure with nodes and edges, enabling developers to design flexible, non-linear workflows that accommodate branches and loops. It mirrors complex decision-making processes resembling the way neural pathways might work. State Management : LangGraph offers built-in tools for state persistence and error recovery, simplifying the maintenance of contextual data across various stages within an application. It can effectively switch between short-term and long-term memory, enhancing interaction quality thanks to such tools as Zep. Tool Integration : With LangGraph, LLM agents can easily collaborate with external services or databases to fetch real-world data, improving the functionality and responsiveness of your applications. Human-in-the-Loop : Beyond automation, LangGraph accommodates human interventions in workflows, which are crucial for decision-making processes that require analytical oversight or ethical consideration. Whether you are building a chatbot with real memory, an interactive story engine, or a team of agents tackling a complex problem, LangGraph turns headache-inducing plumbing into a clean, visual state machine. Getting Started To start with LangGraph, you will need a basic setup that typically involves installing such essential libraries as langgraph and langchain-openai. From there, you can define the nodes (tasks) and edges (connections) within the graph, effectively implementing checkpoints for short-term memory and utilizing Zep for more persistent memory needs. When operating LangGraph, keep in mind the following: Design with Flexibility : Leverage the powerful graph structure to account for potential workflow branches and interactions that are not strictly linear. Interact with Tools Thoughtfully : Enhance but do not replace LLM capabilities with external tools. Provide each tool with comprehensive descriptions to enable precise usage. Employ Rich Memory Solutions : Use memory efficiently, be mindful of the LLM's context window, and consider integrating external solutions for automatic fact management. Now that we have covered the basics of LangGraph, let's dive into a practical example. To achieve this, we will develop an AI agent specifically designed for customer support. This agent will receive email requests, analyze the problem description in the email body, and then determine the request's priority and appropriate topic/category/sector. So buckle up and let's go! To begin, we need to define what a 'Tool' is. You can think of it as a specialized \"assistant manager\" for your agent, allowing it to interact with external functionalities. The @tool decorator is essential here. LangChain simplifies custom tool creation, meaning that first, you define a Python function, and then apply the @tool decorator. Let's illustrate this by creating our first tool. This tool will help the agent classify the priority of an IT support ticket based on its email content: from langchain_core.tools import tool @tool def classify_priority(email_body: str) -> str: \"\"\"Classify the priority of an IT support ticket based on email content.\"\"\" prompt = ChatPromptTemplate.from_template( \"\"\"Analyze this IT support email and classify its priority as High, Medium, or Low. High: System outages, security breaches, critical business functions down Medium: Non-critical issues affecting productivity, software problems Low: General questions, requests, minor issues Email: {email} Respond with only: High, Medium, or Low\"\"\" ) chain = prompt | llm response = chain.invoke({\"email\": email_body}) return response.content.strip() Excellent! Now we have a prompt that instructs the AI to receive the email body, analyze it, and classify its priority as High, Medium, or Low. That’s it! You have just composed a tool your agent can call! Next, let's create a similar tool to identify the main topic (or category) of the support request: @tool def identify_topic(email_body: str) -> str: \"\"\"Identify the main topic/category of the IT support request.\"\"\" prompt = ChatPromptTemplate.from_template( \"\"\"Analyze this IT support email and identify the main topic category. Categories: password_reset, vpn, software_request, hardware, email, network, printer, other Email: {email} Respond with only the category name (lowercase with underscores).\"\"\" ) chain = prompt | llm response = chain.invoke({\"email\": email_body}) return response.content.strip() Now we need to create a state, and in LangGraph this little piece is, kind of, a big deal. Think of it as the central nervous system of your graph. It is how nodes talk to each other, passing notes like overachievers in class. According to the docs: “A state is a shared data structure that represents the current snapshot of your application.” In practice? The state is a structured message that moves between nodes. It carries the output of one step as the input for the next one. Basically, it is the glue that holds your entire workflow together. Therefore, before constructing the graph, we must first define the structure of our state. In this example, our state will include the following: The user’s request (email body) The assigned priority The identified topic (category) It is simple and clean, so you can move through the graph like a pro. from typing import TypedDict # Define the state structure class TicketState(TypedDict): email_body: str priority: str topic: str # Initialize state initial_state = TicketState( email_body=email_body, priority=\"\", topic=\"\" ) Nodes vs. Edges: Key Components of LangGraph The fundamental building blocks of LangGraph include nodes and edges. Nodes : They are the operational units within the graph, performing the actual work. A node typically consists of Python code that can execute any logic, ranging from computations to interactions with language models (LLMs) or external integrations. Essentially, nodes are like individual functions or agents in traditional programming. Edges : Edges define the flow of execution between nodes, determining what happens next. They act as the connectors that allow the state to transition from one node to another based on predefined conditions. In the context of LangGraph, edges are crucial in orchestrating the sequence and decision flow between nodes. To grasp the functionality of edges, let’s consider a simple analogy of a messaging application: Nodes are akin to users (or their devices) actively participating in a conversation. Edges symbolize the chat threads or connections between users that facilitate communication. When a user selects a chat thread to send a message, an edge is effectively created, linking them to another user. Each interaction, be it sending a text, voice, or video message, follows a predefined sequence, comparable to the structured schema of LangGraph’s state. It ensures uniformity and interpretability of data passed along edges. Unlike the dynamic nature of event-driven applications, LangGraph employs a static schema that remains consistent throughout execution. It simplifies communication among nodes, enabling developers to rely on a stable state format, thereby ensuring seamless edge communication. Designing a Basic Workflow Flow engineering in LangGraph can be conceptualized as designing a state machine. In this paradigm, each node represents a distinct state or processing step, while edges define the transitions between those states. This approach is particularly beneficial for developers aiming to strike a balance between deterministic task sequences and the dynamic decision-making capabilities of AI. Let's begin constructing our flow by initializing a StateGraph with the TicketState class we defined earlier. from langgraph.graph import StateGraph, START, END workflow = StateGraph(TicketState) Node Addition : Nodes are fundamental building blocks, defined to execute such specific tasks as classifying ticket priority or identifying its topic. Each node function receives the current state, performs its operation, and returns a dictionary to update the state: def classify_priority_node(state: TicketState) -> TicketState: \"\"\"Node to classify ticket priority.\"\"\" priority = classify_priority.invoke({\"email_body\": state[\"email_body\"]}) return {\"priority\": priority} def identify_topic_node(state: TicketState) -> TicketState: \"\"\"Node to identify ticket topic.\"\"\" topic = identify_topic.invoke({\"email_body\": state[\"email_body\"]}) return {\"topic\": topic} workflow.add_node(\"classify_priority\", classify_priority_node) workflow.add_node(\"identify_topic\", identify_topic_node) The classify_priority_node and identify_topic_node methods will change the TicketState and send the parameter input. Edge Creation : Define edges to connect nodes: workflow.add_edge(START, \"classify_priority\") workflow.add_edge(\"classify_priority\", \"identify_topic\") workflow.add_edge(\"identify_topic\", END) The classify_priority establishes the start, whereas the identify_topic determines the end of our workflow so far. Compilation and Execution : Once nodes and edges are configured, compile the workflow and execute it. graph = workflow.compile() result = graph.invoke(initial_state) Great! You can also generate a visual representation of our LangGraph flow. graph.get_graph().draw_mermaid_png(output_file_path=\"graph.png\") If you were to run the code up to this point, you would observe a graph similar to the one below: This illustration visualizes a sequential execution: start, followed by classifying priority, then identifying the topic, and, finally, ending. One of the most powerful aspects of LangGraph is its flexibility, which allows us to create more complex flows and applications. For instance, we can modify the workflow to add edges from START to both nodes with the following line: workflow.add_edge(START, \"classify_priority\") workflow.add_edge(START, \"identify_topic\") This change will imply that the agent executes classify_priority and identify_topic simultaneously. Another highly valuable feature in LangGraph is the ability to use conditional edges. They allow the workflow to branch based on the evaluation of the current state, enabling dynamic routing of tasks. Let's enhance our workflow. We will create a new tool that analyzes the content, priority, and topic of the request to determine whether it is a high-priority issue requiring escalation (i.e., opening a ticket for a human team). If not, an automated response will be generated for the user. @tool def make_escalation_decision(email_body: str, priority: str, topic: str) -> str: \"\"\"Decide whether to auto-respond or escalate to IT team.\"\"\" prompt = ChatPromptTemplate.from_template( \"\"\"Based on this IT support ticket, decide whether to: - \"auto_respond\": Send an automated response for simple/common or medium priority issues - \"escalate\": Escalate to the IT team for complex/urgent issues Email: {email} Priority: {priority} Topic: {topic} Consider: High priority items usually require escalation, while complex technical issues necessitate human review. Respond with only: auto_respond or escalate\"\"\" ) chain = prompt | llm response = chain.invoke({ \"email\": email_body, \"priority\": priority, \"topic\": topic }) return response.content.strip() Furthermore, if the request is determined to be of low or medium priority (leading to an \"auto_respond\" decision), we will perform a vector search to retrieve historical answers. This information will then be used to generate an appropriate automated response. However, it will require two additional tools: @tool def retrieve_examples(email_body: str) -> str: \"\"\"Retrieve relevant examples from past responses based on email_body.\"\"\" try: examples = iris.cls(__name__).Retrieve(email_body) return examples if examples else \"No relevant examples found.\" except: return \"No relevant examples found.\" @tool def generate_reply(email_body: str, topic: str, examples: str) -> str: \"\"\"Generate a suggested reply based on the email, topic, and RAG examples.\"\"\" prompt = ChatPromptTemplate.from_template( \"\"\"Generate a professional IT support response based on: Original Email: {email} Topic Category: {topic} Example Response: {examples} Create a helpful, professional response that addresses the user's concern. Keep it concise and actionable.\"\"\" ) chain = prompt | llm response = chain.invoke({ \"email\": email_body, \"topic\": topic, \"examples\": examples }) return response.content.strip() Now, let's define the corresponding nodes for those new tools: def decision_node(state: TicketState) -> TicketState: \"\"\"Node to decide on escalation or auto-response.\"\"\" decision = make_escalation_decision.invoke({ \"email_body\": state[\"email_body\"], \"priority\": state[\"priority\"], \"topic\": state[\"topic\"] }) return {\"decision\": decision} def rag_node(state: TicketState) -> TicketState: \"\"\"Node to retrieve relevant examples using RAG.\"\"\" examples = retrieve_examples.invoke({\"email_body\": state[\"email_body\"]}) return {\"rag_examples\": examples} def generate_reply_node(state: TicketState) -> TicketState: \"\"\"Node to generate suggested reply.\"\"\" reply = generate_reply.invoke({ \"email_body\": state[\"email_body\"], \"topic\": state[\"topic\"], \"examples\": state[\"rag_examples\"] }) return {\"suggested_reply\": reply} def execute_action_node(state: TicketState) -> TicketState: \"\"\"Node to execute final action based on decision.\"\"\" if state[\"decision\"] == \"escalate\": action = f\"&#x1f6a8; ESCALATED TO IT TEAM\\nPriority: {state['priority']}\\nTopic: {state['topic']}\\nTicket created in system.\" print(f\"[SYSTEM] Escalating ticket to IT team - Priority: {state['priority']}, Topic: {state['topic']}\") else: action = f\"&#x2705; AUTO-RESPONSE SENT\\nReply: {state['suggested_reply']}\\nTicket logged for tracking.\" print(f\"[SYSTEM] Auto-response sent to user - Topic: {state['topic']}\") return {\"final_action\": action} workflow.add_node(\"make_decision\", decision_node) workflow.add_node(\"rag\", rag_node) workflow.add_node(\"generate_reply\", generate_reply_node) workflow.add_node(\"execute_action\", execute_action_node) The conditional edge will then use the output of the make_decision node to direct the flow: workflow.add_conditional_edges( \"make_decision\", lambda x: x.get(\"decision\"), { \"auto_respond\": \"rag\", \"escalate\": \"execute_action\" } ) If the make_escalation_decision tool (via decision_node) results in \"auto_respond\", the workflow will proceed through the rag node (to retrieve examples), then to generate_reply (to craft the response), and finally to execute_action (to log the auto-response). Conversely, if the decision is \"escalate\", the flow will bypass the RAG and take generation steps, moving directly to execute_action to handle the escalation. To complete the graph by adding the remaining standard edges, do the following: workflow.add_edge(\"rag\", \"generate_reply\") workflow.add_edge(\"generate_reply\", \"execute_action\") workflow.add_edge(\"execute_action\", END) Dataset Note: For this project, the dataset we used to power the Retrieval-Augmented Generation (RAG) was sourced from the Customer Support Tickets dataset on Hugging Face . The dataset was filtered to include exclusively the items categorized as 'Technical Support' and restricted to English entries. It ensured that the RAG system retrieved only highly relevant and domain-specific examples for technical support tasks. At this point, our graph should resemble the one below: When you execute this graph with an email that results in a high priority classification and an \"escalate\" decision, you will see the following response: At the same time, a request that is classified as low priority and results in an \"auto_respond\" decision will trigger a reply resembling the one below: So... Is It All Sunshine? Not entirely. There a few bumps to watch out for: Data Privacy: Be careful with sensitive info — these agents require guardrails. Compute Costs: Some advanced setups require serious resources. Hallucinations: LLMs can occasionally make things up (still smarter than most interns, though). Non-Determinism: The same input might return different outputs, which is great for creativity, but tricky for strict processes. However, most of these weak spots can be managed with good planning, the right tools, and — you guessed it — a bit of reflection. LangGraph turns AI agents from buzzwords into real, working solutions. Whether you want to automate customer support, handle IT tickets, or build autonomous apps, this framework makes it doable and, actually, enjoyable. Have you got any questions or feedback? Let’s talk. The AI revolution needs builders like you. Check the related application on InterSystems Open Exchange"
}