{
  "metadata": {
    "key": "page:https://www.sciencedirect.com/topics/computer-science/python-language",
    "created": 1769878775.663681,
    "ttl": 604800
  },
  "data": "Python Language In subject area: Computer Science Python Language is a programming language created by Guido van Russom in the late 1980s, known for its readability, extensibility, and a wide range of third-party libraries. It is widely used by programmers of varying backgrounds and abilities for developing software applications. AI generated definition based on: Python Forensics , 2014 How useful is this definition? Press Enter to select rating, 1 out of 3 stars Press Enter to select rating, 2 out of 3 stars Press Enter to select rating, 3 out of 3 stars About this page Add to Mendeley Set alert Chapters and Articles You might find these chapters and articles relevant to this topic. Chapter Why Python Forensics? 2014 , Python Forensics Chet Hosmer Global support for Python Python was created by Guido van Russom in the late 1980s with the fundamental premise that Python is programming for everyone. This has created a groundswell of support from a broad array of domain-specific researchers, the general software development community, and programmers with varying backgrounds and abilities. The Python language is both general purpose and produces easily readable code that can be understood by nonprogrammers. In addition, due to Python’s intrinsic extensibility, copious amount of third-party libraries and modules exist. Numerous web sites provide tips, tricks, coding examples, and training for those needing a deeper dive into the language. It may surprise you that Python was ranked as the number 1 programming language in 2013 by codeeval.com (see Figure 1.5 ) edging out Java for the first time. A great place to start is at the official Python programming language web sites python.org . Figure 1.5 . Programming language popularity according to codeview.com . Finally, sophisticated integrated software development environments exist that allow even the novice developer to innovate new ideas and design, and then build and test their inventions and prototypes. Python is an interpreted language; however, compilers are available as well, of course. As shown in Figure 1.6 , developers have adopted the test-then code-then validate mindset. Figure 1.6 . Test-then code-then validate. By utilizing the Python Shell, experienced and novice users alike can experiment with the language, libraries, modules, and data structures before attempting to integrate them into a complete program or application. This promotes experimentation with the language, language constructs, objects, experimentation with performance considerations, and libraries, and allows users to explore and tradeoff approaches prior to putting them into practice. Once confident with the use, characteristics and behaviors of the language, the integration into working programs tends to go more smoothly. In addition, this experimentation often leads to testing considerations that can then be applied to the working programs once they have been completed, thus completing the cycle of test-code-validate. Show more Read full chapter View PDF Explore book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780124186767000013 Book 2014 , Python Forensics Chet Hosmer Chapter Machine learning model development 2021 , Thinking Machines Shigeyuki Takano 5.4 Python script language and virtual machine 5.4.1 Python and optimizations C language cannot change the data type because of the type declaration at the beginning of the function description. Dynamic language (called a script language) such as Python does not declare the data type [250] . Python is a simple language, and its code footprint is relatively small. In addition, Python and its environment are open-source and free of charge. An optimization should be applied through the following steps; however, they tend to be neglected, so we should keep them in mind [175] . 1. Profiling what occurs in the code, 2. Improve the slow parts of a code, and 3. Check the updated part with profiling There are three major reasons for a lower execution performance and high resource consumption [175] . • CPU bound This state is a highly computationally demanding workload on a processor. Vectorization and SIMD can relax the pressure. A low workload is related to the memory bound issue, and we need to check the memory bank conflict for operands. • Memory bound A mismatch between the data structure and the algorithm is a state of unnecessary memory accesses and thus creates memory conflicts. We can check this state by calculating the ratio of the total memory accesses to the real number of memory accesses. In terms of operation, this concerns the data structure, and it is important to use the correct structure. • I/O bound This state is a waiting time for the I/O processing. Asynchronous processing is used to eliminate the waiting time, or kick to another task during this state. Multi-threading creates this state. Optimization on Python has a difficulty of vectorization and SIMDizing owing to its following specifications [175] . 1. A Python object does not guarantee an optimal memory allocation Python supports garbage collection, an automatic reservation, and its release, and thus a memory fragmentation 2 easily occurs with it. 2. Python applies an auto type setting, and not a compiler, which creates certain issues The order of the code execution can be changed dynamically, thus making code (algorithm) optimization difficult. 5.4.2 Virtual machine Python language is a script language running on a VM. The VM emulates a computer system, particularly a processor and memory system. A processor in Python VM takes a stack type rather than an R-R type, of which all operands are in an RF. 3 Python VM interprets a Python script as a byte code (instruction set) on the operating software. An emulator engine executes the interpreted instruction fragments. In detail, the emulator engine executes the program corresponding to the byte code. A VM system constructs a memory image consisting of a running source code, and in the VM, the processor fetches from memory and executes the byte codes. Thus, similar to a traditional computer, it has context information. 4 By switching contexts, several processes can be run on the VM. In addition, a dispatch type (decode and dispatch method) emulator engine executes the interpreted routine corresponding to the byte code implemented with the mechanism of the dispatcher used in a traditional processor. Fig. 5.4 shows a common block diagram used in a VM [329] . The loader composes a memory image of the source code to execute. It is efficient to interpret from the source code to the byte code during the composition. Read composed byte code from memory image, or interpreting to bytecode when the reading one line of source code which is not yet interpreted to byte code, and VM executes a program corresponding to the byte code. It references the context upon execution and emulates the mechanism of a stack-type processor. Figure 5.4 . Process virtual machine block diagram [329] . A different platform for a specific VM has different memory addressing modes, and therefore the memory address translation is important. For example, it checks for a small endian (the byte data order is based on the elder address) or a big endian (the byte data order is based on the older address), and fetches the byte data from memory in the VM. Show more Read full chapter View PDF Explore book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780128182796000153 Book 2021 , Thinking Machines Shigeyuki Takano Chapter Quick and Dirty Python 2015 , Hacking Web Intelligence Sudhanshu Chauhan , Nutan Kumar Panda Introduction After covering many interesting topics related to utilizing different automated tools, in this chapter we will be learning to create some. Sometimes there is a need to perform some specific task for which we are not able to find any tools which suits the requirements, this is when we have some basic programming knowledge so that we can quickly create some code to perform the desired operation. This chapter will touch upon the basics of Python programming language. We will understand why and how to use Python, what are the basic entities and then we will move on to create some simple but useful code snippets. It is advised to have some programming knowledge before moving on with this chapter as we will be covering the basic essentials related to the language and jump straight into the code. Though the examples used would be simple yet having some programming experience would be helpful. Anyone who has some interest in computer science is familiar with the concept of programming. In simple terms it is the process of creating a program to solve a problem. To create this program we require to have a language using which we can write instructions for computer to understand and perform the task. The simple objective of a computer program is to automate a series of instructions so that they need not to be provided one by one manually. Programming versus scripting The language we are going to be discussing in this chapter is Python, which is commonly termed as a scripting language, so before moving further let’s understand what that means. Usually the code written in a programming language is compiled to machine code using a program called compiler to make it executable. For example, code written in C++ language is compiled to create an exe file which can be executed in a Windows platform. There is another program called as an interpreter which allows running a language code without being compiled. So if the execution environment for a piece of code is an interpreter it is a script. Usually Python is executed in such environment and hence is commonly called a scripting language. This does not mean that a scripting language cannot be compiled, it simply is not usual. All scripting languages are programming languages. Introduction to Python Python is a high-level programming language created by Guido Van Rossum, which emphases on the readability of code. Python is very fast and allows solving problem with minimum amount of code and hence is very popular among people who need to create quick scripts on the go, such as pentesters. There are various versions of Python but we will be focusing on the 2.7 version in this chapter. Though the latest version as of now is 3.4, yet most of the Python tools and libraries available online are based on the 2.7 version and the 3.x version is not backward compatible and hence we will not be using it. There are some changes in 3.x version but once we get comfortable with 2.7 it won’t require much effort to move to it, if required. The main agenda behind this chapter is not to create a course on Python that would require a separate book in itself. Here we will be covering the basics quickly and then move on to creating small and useful scripts for general requirements. The aim is to understand Python, write quick snippets, customize existing tools, and create own tools as per requirements. This chapter strives to introduce the possibilities of creating efficient programs in a limited period of time, provide the means to achieve it, and then further extend it as required. There are other alternatives to Python available, mainly Ruby and Perl. Perl is one of the oldest scripting languages and Ruby is being widely used for web development (Ruby on Rails) yet Python is one of the easiest and simplest language when it comes to rapidly creating something with efficiency. Python is also being used for web development (Django). Installation Installing Python in Windows is pretty straight forward, simply download the 2.7 version from https://www.python.org/downloads/ and go forward with the installer. Linux and other similar environments mostly come preinstalled with Python. Though, it is not mandatory yet highly recommended to install Setuptools and Pip for easy installation and management of Python packages. Details related to Setuptools and Pip can be found at https://pypi.python.org/pypi/setuptools and https://pypi.python.org/pypi/pip respectively. Modes We can run Python basically in two ways, one is to directly interact with the interpreter, where we provide the commands through direct interaction and see the output of it (if any) and other one is through scripts, where we write the code into a file, save it as filename.py and execute it using the interpreter. Though writing the script is a better way of writing a code which could be used and modified later yet the interactive mode is also very helpful. We can quickly check how a command works, what are its attributes, we can quickly try something that we want to write and see the results, and we can test and debug our code easily and also get help related to any command quickly. It is also a good practice to start with the interpreter to learn about the different aspects of the language and then utilize them to create the script by combining the blocks. Hello World program So for the customary “Hello World” program, we can simply go ahead into the Python interpreter by typing “Python” and write the code. Figure 13.1 . Hello World example. print “Hello World” This prints “Hello World” into the interpreter and it can’t get simpler than this. If we want this in a script form then we can write the same code in a text file and save it as helloworld.py. Now to execute it we need to call this file through Python. python helloworld.py In Windows we can also call the script file simply from the command prompt to run our script or by double clicking on the script file. In Linux environment we can execute this script directly using the dot slash notation, but for that first we need to make the file executable using the command “chmod.” chmod 755 helloworld.py ./helloworld.py Though it is not mandatory it is a good practice to specify Python environment into the script file itself through shebang notation. For this we simply need to include the following line at the starting of the script file. #!/usr/bin/python It simply specifies where is the interpreter required to execute this file. This is only supported in Linux environment but including it into the code does not have any change in Windows environment so it is better to include it so that the same code can execute in both the environments. If multiple interpreters are installed in Linux then we can simply change the environment path to the one suitable for our code, for example, if both Python 3.0 and 2.7 are installed we can write #!/usr/bin/Python2.7 to use the 2.7 interpreter to execute our code. Identifiers In programming, identifiers are the names used to identify any variable, function, class, and other similar objects used in a program. In Python, they can start with an alphabet or an underscore followed by alphabets, digits, and underscore. They can contain a single character also. So we can create identifiers accordingly, except certain words which are reserved for special purposes, for example, “for,” “if,” “try,” etc. Python is also case sensitive which means “test” and “Test” are different. Data types Python has different variable types, but is decided by the value passed to it and does not require to be stated explicitly. Actually the data type is not associated with the variable name but the value object and the variable simply references to it. So a variable can be assigned to another data type after it already refers to a different data type. Figure 13.2 . Value assignment. Commonly used data types are: • Numbers • String • Lists • Tuples • Dictionaries To define a number simply assign a variable with a number value, for example, >>>samplenum=10 Just to know there are various types of numerical such as float, long, etc. To define a string we can use the help of quotes (both single and double), for example, >>>samplestr=”This is a string” >>>samplestr2=’This is another string’ We can also utilize both the types of quotes in a nested form. To create multiline strings we can use triple quotes. Figure 13.3 . Triple quotes. We can also utilize the % operator for strings to include different data types. The values are passed in a tuple (discussed later) and %d is for integers, %s is for strings, %f for float. Example code >>>sample_str=”There are total %d number of floors in the %s building”%(4,’xyz’) >>>sample_str There are total 4 number of floors in the xyz building Python provides an interesting data type called list and according to its name it is a list of variables of different types. To create a list we can utilize square brackets and separate the variables with commas. >>>samplelist=[123, “str”, ‘xyz’, 321, 21.22] >>>samplelist [123, “str”, ‘xyz’, 321, 21.22] >>>samplelist[1] ‘str’ Tuples are similar to lists but are immutable and are created using parentheses. Figure 13.4 . List and tuples. Dictionary is another interesting data type which consists of items with values associated with them. In these key-value pairs the key needs to be unique whereas the value can change. >>>sampledict={‘test1’:’123’,’test2’:’234’,’test3’:’345’} >>>sampledict[‘test1’] ‘123’ >>>sampledict[‘test4’]=’456’ >>>sampledict[‘test3’]=’333’ >>>sampledict {‘test1’: ’123’, ’test2’: ’234’, ’test3’: ’333’, ’test4’: ’456’} There are also various functions provided by different object which can be of great help at times, instead of writing whole new set of code to perform it. To find out these we can get help from Python functions “dir” and “help”. >>>dir(sampledict) >>>help(sampledict) Figure 13.5 . Using Python help. We have demonstrated some basics of data types but there is much more operations which can be performed on these data types. Some basic examples are shown below: >>>a=12 >>>b=2 >>>a∗b 24 >>>a=”test” >>>b=”next” >>>a+b ‘test next’ >>>lt1=[‘1’,’2’,’3’] >>>lt2=[‘4’,’5’,’6’] >>>lt1+lt2 [‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’] We can perform various operations on these elements. Some examples are shown below. >>>a=1 >>>b=2 >>>a+b 3 >>>a=”test” >>>b=”string” >>>a+b ‘teststring’ >>>a.upper() ‘TEST’ >>>c=”This is a string” >>>c.find(‘ring’) 12 >>>c.find(‘xyz’) -1 >>>sample_list=[‘qw’,’er’,’ty’,123] >>>sample_list.append(456) >>>sample_list [‘qw’, ’er’, ’ty’, 123, 456] Indentation Before moving further let’s clear up on one import concept of Python. Python supports code readability. Unlike other languages such as C++ it does not use brackets to specify the code blocks, whereas uses indentation. So when creating a block of code we need to provide whitespaces to indicate the structure. One important point is that we can have variable number of spaces for indentation but within a block all the statements should have the same amount. Some people use spaces for indentation and some use the tab feature, it is better to stick with one and not mix up both in a single code. The examples shown in the following chapter will work on this concept and we will be using spaces. Basic terms (class, function, conditional statements, loops, etc.) Now let’s move forward with conditional statements. The most basic conditional statement is “if.” The logic is simple, if the provided condition is it will execute the statement, else it will move on. Basic structure of “if” and associated conditions is shown below. if condition: then_this_statement elif condition: then_this_statement else: this_condition Example code #!/usr/bin/python a=10 b=12 c=15 if (a==b): print “a=b” elif (b==c): print “b=c” elif (c==a): print “c=a” else: print “none” Write this in a notepad file and save it as if_con.py. This code will result in the response “none,” when executed in Python. The “elif” and “else” conditions are not mandatory when using “if” statement and we can have multiple “elif” statements. Similarly we can also have nested “if” conditions where there will be if statements within another if statement, just proper indentation needs to be kept in mind. if condition: then_this_statement if nested_condition: then_this_nested_statement else nested-else_condition: then_this_nested-else_statement The “while” loop is next in line. Here we will provide the condition and the loop will run until that condition is true. Structure of “while” is shown below. while this_condition_statement_is-true: run_this_statement Example code #!/usr/bin/python a=10 c=15 while (a<c): print a a=a+1 Output 10 11 12 13 14 We can also utilize “break” and “continue” statement to control the flow of the loop. The “break” statement is used to break out of the current loop and the “continue” statement is used to pass the control back to the starting of the loop. There is one more interesting statement called “pass” which does nothing, in particular is used just as a placeholder. Another useful conditional statement is “for” loop. Using it we can iterate through the items present within an object such as a tuple or list. Example code #!/usr/bin/python sample_tup=(‘23’,’test’,12,’w2’) for items in sample_tup: print items Output 123 test 12 w2 We are simply passing the individual values in the tuple sample_tup and putting them inside the variable items one by one and printing them. Example code #!/usr/bin/python str=“String” for items in str: print items Output S t r i n g We can also utilize the attributes of the objects (find through “dir” and “help”) for the iteration purpose. Similar to “while” we can also use “break” and “continue” statements in “for” loop as well. Now we are done with the conditional statements and move forward with other structures. Modules Sometimes there is a need to reuse the code or manage it depending upon our requirement, this is where modules come into picture. Say there are multiple components of an object and these components are also required in some other object, so instead of creating these components again and again we can simply create and store them separately and call them into the object as and when required. For example, creating a program for an entity car and another for truck, both will have common components such as brakes, accelerator, etc., so we will code these components once and simply call them into the program according to the requirement, instead of creating them again and again. This is very helpful in organizing and managing the code. Modules can define variables, functions, and classes, we will discuss about these shortly. Once we create these and save them in separate files, we can import them into our code and use their functionalities. Example code #!/usr/bin/python y=“Module String” Save this as x.py. Create another file called mod.py and save the following code into it: #!/usr/bin/python import x print x.y output Module String So we simply created a module with just a variable, called it into another code and used its variable. Utilizing modules we can create complex programs without cluttering all the code into a single file. We can also import a module using the call “from module_name import desired_portion”. Let’s learn about functions and classes. Functions Functions help to group a set of code as a single functionality, which is useful in code with large number of lines of code. Function start with the keyword “def” followed by the function name and then the parenthesis inside which the arguments are placed and then the colon. Functions also contain a return statement to terminate it and pass back values (can be null). To call a function we can use its name along with the values to be passed (inside the parenthesis). Example code #!/usr/bin/python def simplefunc(atr_arg): print “Print me first” print atr_arg return str=“Sample String” simplefunc(str) Output Print me first Sample String Classes Using classes we can group different operations together. To create a class we simply need to start with the keyword class followed by a name for the class and then a colon. Example code #!/usr/bin/python class sample_class: def __init__(self, classarg): self.cla=classarg def firstfunc(self): print “First Function” return self.cla+“ Return” def secfunc(self): print “Second Function” return self.cla+“ Return” classobj=sample_class(“Argument”) print classobj.firstfunc() print classobj.secfunc() Output First Function Argument Return Second Function Argument Return Here the function __init__ is the constructor of the class and is the first function which runs in the class. The variable “classobj” is the object for the class “sample_class” and using it we can communicate with the objects inside the class. As discussed earlier we can also create this as a module and call it inside another program. As discussed earlier, let’s take another example of importing modules. Example code #!/usr/bin/python class sample_class: def __init__(self, classarg): self.cla=classarg def firstfunc(self): print “First Function” return self.cla+“ Return” def secfunc(self): print “Second Function” return self.cla+“ Return” classobj=sample_class(“Argument”) This file is being saved as mod.py and another file calls this as a module with the code: #!/usr/bin/python from mod import ∗ print classobj.firstfunc() Output First Function Argument In Python we can also create directory of modules for better organization through packages. They are hierarchical structures and can contain modules and subpackages. Working with files Sometimes there is a need to save or retrieve data from files for this we will learn how to deal with files in Python. First of all, to open a file we need to create an object for it using the function open and provide the mode operation. >>>sample_file=open(‘text.txt’,“w”) Here the name sample_file is the object and using open function we are opening the file text.txt. If the file with this name does not already exists it will be created and if already exists it will be overwritten. The last portion inside the parenthesis describes the mode, here it is w which means write mode. Some other commonly used modes are “r” for reading, “a” for append, “r+” for both read and write without overwriting, and “w+” for read and write with overwriting. Now we have created an object so let’s go ahead and write some data to our file. >>>sample_file(“test data”) Once we are done with writing data to the file we can simply close it. >>>sample_file.close() Now to read a file we can do the following: >>>sample_file=open(‘text.txt’,“r”) >>>sample_file.read() ‘test data’ >>>sample_file.close() Similarly we can also append data to files using “a” mode and write() function. Python has various inbuilt as well as third party modules and packages which are very useful. In case we encounter a specific problem that we need to solve using Python code it is better to look for an existing module first. This saves a lot of time figuring out the steps and writing huge amount of code through simply importing the modules and utilizing the existing functions. Let’s check some of these. Sys As stated in its help file this module provides access to some objects used and maintained by interpreter and functions that strongly interact with it. To use it we import it into our program. import sys Some of the useful features provided by it are argv, stdin, stdout, version, exit(), etc. Re Many times we need to perform pattern matching to extract relevant data from a large amount of it. This is when regular expressions are helpful. Python provides “re” module to perform such operations. import re Os The “os” module in Python allows to perform operating system-dependent functionalities. import os Some sample usages are to create directories using mkdir function, rename a file using rename function, kill a process using kill function and display list of entries in a directory using listdir function. Urllib2 This module allows to perform URL-related operations such as open a web page. It is very helpful when working with web applications. import urllib2 There are many other useful modules such as Scapy (network), Scrapy (web scraping), nose (testing), mechanize (stateful web browsing), and others which provide huge amount of functionalities in their domain. Some modules are inbuilt and some need to be installed separately. There is still much more to explore in this topic but here we will be stopping with these points and move on to the next topic. User input Certain problems require to take user input. Here are two methods to do so: Using Sys module we can take user input from command line argument. Example code #!/usr/bin/python import sys a=sys.argv[1] print a print a∗4 a=int(a) print a print a∗4 Save this as usrinp.py and pass the command line argument. C:\\Python27>usrinp.py 2 Output 2 2222 2 8 argv is a list that takes command line arguments where the index 0 is reserved for filename. We can also pass multiple values and iterate by changing the index value of argv. Here we have also demonstrated a simple type conversion (string to integer). Another method is to get input at run time, this can be done using raw_input. Example code #!/usr/bin/python import sys a=raw_input(“Enter something: ”) print a∗4 When executing this code, it will prompt the message “Enter something”, once we input the value it will generate the response accordingly. For an input value “a” it will generate the output “aaaa”. Common mistakes Some common issues faced during the execution of Python code are as follows. Indentation As shown in examples above, Python uses indentations for grouping the code. Some people use spaces for this and some use tabs. When running the code written by some person or modifying it we sometimes face the indentation error. To resolve this error, check the code for proper indentation and correct the instances; also make sure to not mess up by using tabs as well as spaces in the same code as it creates confusion for the person looking at the code. Libraries Sometimes people have a completely correct code, yet it fails to execute with a library error. The reason is missing of a library that is being called in the code. Though it is a novice mistake, sometimes experienced people also don’t read the exact error and start looking for errors in the code. The simple solution is to install the required library. Interpreter version Sometimes the code is written for a specific version of the language and when being executed in a different environment, it breaks. To correct this, install the required version and specify it in the code as shown earlier in this chapter or execute the code using the specific interpreter. Sometimes there are multiple codes which require different versions; to solve this problem we can use virtualenv, which allows us to create an isolated virtual environment where we can include all the dependencies to run our code. Permission Sometimes the file permissions are not set properly to execute the code so make the changes accordingly using chmod. Quotes When copying code from some resources such as documents and websites there is a conversion between single quote (‘) and grave accent (`) which causes errors. Identify such conversions and make the changes to the code accordingly. So we have covered basics about the language let’s see some examples which can help us to understand the concepts and understand their practical usage and also get introduced to some topics not discussed above. Similar to shodan, discussed in a previous chapter there is another service called zoomeye. In this example we will be creating a script using which will query zoomeye and extract the IP address from the result page. We have to pass the query term from command line. For this we will first create the URL for this by combining the base URL and the search term passed through command line. Then we will send the request to this URL using the function urlopen from the module urllib2. Further we will be parsing the response page and extract the IP addresses from it using BeautifulSoup. #!/usr/bin/python import sys import urllib2 from bs4 import BeautifulSoup url=“ http://www.zoomeye.org/search?q= ” term=sys.argv[1] comurl=url+term response=urllib2.urlopen(comurl) soup = BeautifulSoup(response) for item in soup.findAll(“a”,{‘class’:’ip’}): print item.string Figure 13.6 . Zoomeye script result. For our next example we will create an extension for Burp Suite. Burp Suite is an application proxy which is used for web application security assessment. It allows to create extensions through which we can extend its functionalities. For our extension we will simply extract the host name of the target. #! /usr/bin/python # A sample burp extension in python (needs jython) which extracts hostname from the request (Target Tab). from burp import IBurpExtender from burp import IMenuItemHandler import re import urllib2 class BurpExtender(IBurpExtender): def registerExtenderCallbacks(self, callbacks): self.mCallBacks = callbacks self.mCallBacks.registerMenuItem(“Sample Extension”, hostnamefunc()) class hostnamefunc(IMenuItemHandler): def menuItemClicked(self, menuItemCaption, messageInfo): print “--- Hostname Extract ---” if messageInfo: request1=HttpRequest(messageInfo[0].getRequest()) req=request1.request host=req[1] print host print “DONE” class HttpRequest: def __init__(self, request): self.request=request.tostring().splitlines() To make this extension run, first we need to install Jython and configure it under the options tab within extender. Once this is done we can add our extension under the Extensions tab within extender. To use our extension we simply need to right click on a target domain under the target tab and click on the “Sample Extension” on the right click menu, the result will be shown in the Extensions in extender tab. The example is simply to demonstrate an extension using Python we can further enhance it by performing other operations on the host name. Maltego transforms In a previous chapter we discussed about Maltego, a simple and effective open source intelligence (OSINT) tool. We learned how to use it, what all features it provided, what are its elements, etc. Let’s take this a step further and utilizing the knowledge of Python we have just acquired to extend this framework. As mentioned in a previous chapter, the power of Maltego lies in its transforms. For quick recall a transform is basically a piece of code which takes an entity (or a group of entities) as an input and extracts data in the form of entity (or entities) based upon the relationship. Maltego has a lot of inbuilt transforms and keeps on updating the framework with new ones, but it also allows to create new ones and use them, this can be very helpful when we need something custom according to our needs. Before we move any further we need the “MaltegoTransform” Python library by Andrew MacPherson, which is very helpful in local transform development. It can be downloaded from the page https://www.paterva.com/web6/documentation/developer-local.php . Some basic examples of local transforms created using the library are also present at the bottom of the page. Once we have the library in our directory we are ready to go and create our own first transforms. To create any program first we need to have a problem statement. Here we need to create a transform so let’s first identify something that would be helpful during our OSINT exercise. There is a service called as HaveIBeenPwned ( https://haveibeenpwned.com ) created by Troy Hunt which allows users to check if their account has been compromised in a breach. It also provides an application programming interface (API) using which we can perform the same function. We will be using the v1 of the API ( https://haveibeenpwned.com/API/v1 ) and provide an e-mail address to check if our supplied e-mail has any account associated. To utilize the API we simply need to send a GET request to the service in the form shown below and it will provide a JSON response to show the website names. https://haveibeenpwned.com/api/breachedaccount/ {account} Let’s first specify the path of the interpreter #!/usr/bin/python Now we need to import the library MaltegoTransform from MaltegoTransform import ∗ Once we have the main library we need to import some other libraries that will be required. Library “sys” is to take user input and urllib2 to make the GET request. import sys import urllib2 Once we have imported all the required libraries, we need to assign the function MaltegoTransform() to a variable and pass the user input (e-mail address) from Maltego interface to it. mt = MaltegoTransform() mt.parseArguments(sys.argv) Now we can pass the e-mail value to a variable so that we can use it to create the URL required to send the GET request. email=mt.getValue() Let’s create a variable and save the base URL in it. hibp=“ https://haveibeenpwned.com/api/breachedaccount/ ” As we have both the parts of the complete URL, now we can simply combine them to create the complete URL. getrequrl=hibp+email Let’s send the GET request using the function urlopen in the library urllib2 and store the response in a variable, but while handling the exception. Now we need to run a for loop to go through the values being stored in the variable (response) and add these values to the variable for the transform. try: response = urllib2.urlopen(getrequrl) for rep in response: mt.addEntity(“maltego.Phrase”,“Pwned at ” + rep) except: print “” In this last step we need to return the output of the variable. mt.returnoutput() Now simply save this as emailhibp.py. Complete code #!/usr/bin/python from MaltegoTransform import ∗ import sys import urllib2 mt = MaltegoTransform() mt.parseArguments(sys.argv) email=mt.getValue() hibp=“ https://haveibeenpwned.com/api/breachedaccount/ ” getrequrl=hibp+email try: response = urllib2.urlopen(getrequrl) for rep in response: mt.addEntity(“maltego.Phrase”,“Pwned at ” + rep) except: print “” mt.returnoutput() Now to check if our code is running properly we simply need to execute this program in the terminal and pass an e-mail address as a command line argument. Example ./emailhibp.py [email protected] or python ./emailhibp.py [email protected] Figure 13.7 . Transform output. We can see that the response is a XML styled output and contains the string “Pwned at [“Adobe”,“Gawker”,“Stratfor”]”. This means our code is working properly and we can use this as a transform. Maltego takes this XML result and parses it to create an output. Now our next step is to configure this as a transform in Maltego. Under the manage tab go to Local Transform button to start the Local Transform Setup Wizard. This wizard will help us to configure our transform and include it into our Maltego instance. In the Display name field provide the name for the transform and press tab, it will generate a Transform ID automatically. Now write a small description for the transform in the Description field and the name of the Author in the Author field. Next we have to select what would be the entity type that this transform takes as input, in this case it would be Email Address. Once the input entity type is selected we can choose the transform set under which our transform would appear which can also be none. Figure 13.8 . Transform setup wizard. Now click on next and move to the second phase of the wizard. Here under the command field we need to provide the path to the programming environment we are going to use to run the transform code. In our case it would be /usr/bin/python (for Linux) C:\\Python27/python.exe (for Windows) Once the environment is set we can move to the parameters field, here we will provide the path to our transform script. For example, /root/Desktop/transforms/emailhibp.py (for Linux) C:\\Python27\\transforms\\emailhibp.py (for Windows) One point to keep in mind here is that if we select the transform file using the browse button provided in front of the “Parameters” field, then it will simply take the file name in the field, but we need absolute path of the transform to execute it so provide the path accordingly. Figure 13.9 . Transform setup wizard. After all the information is filled into the place we simply need to finish the wizard and our transform is ready to run. To verify this, simply take an e-mail address entity and select the transform from the right click menu. Figure 13.10 . Select transform. Figure 13.11 . Transform execution. Now we have created our first transform and also learned how to configure it in Maltego. Let’s create another simple transform. For this example we will be using the website http://www.my-ip-neighbors.com/ . It allows to perform a reverse IP domain lookup, simply said the domains sharing the same IP address as the one of the provided domain. As in the previous transform we provided an e-mail address as the input here we require a domain name, but this website provides no API service and hence we will have send the raw GET request and extract the domains out of the web page using regular expressions through the library “re”. #!/usr/bin/python from MaltegoTransform import ∗ import sys import urllib2 import re mt = MaltegoTransform() mt.parseArguments(sys.argv) url=mt.getValue() mt = MaltegoTransform() opencnam=“ http://www.my-ip-neighbors.com/?domain= ” getrequrl=opencnam+url header={‘User-Agent’:’Mozilla’} req=urllib2.Request(getrequrl,None,header) response=urllib2.urlopen(req) domains=re.findall(“((?:[0-9]∗[a-z][a-z\\\\.\\\\d\\\\-]+)\\\\.(?:[0-9]∗[a-z][a-z\\\\-]+))(?![\\\\w\\\\.])”,response.read()) for domain in domains: mt.addEntity(“maltego.Domain”, domain) mt.returnoutput() ∗ http://txt2re.com/ can be used to create regular expressions. Similarly we can create lot of transforms which utilize online services, local tools (e.g., Nmap scan), and much more using Python. The examples shown above and some more can be found at https://github.com/SudhanshuC/Maltego-Transforms . Some other interesting transforms can be found at https://github.com/cmlh , else they are just a quick Github search away ( https://github.com/search?utf8=%E2%9C%93&q=maltego+transform ). There is also a Python-based framework available, which allows creating Maltego tranforms easily called as Canari ( http://www.canariproject.com/ ). There are various topics which we have not covered but the scope is limited and topic is very vast. Some of these are exception handling, multiprocessing, and multithreading. Below there are some resources which can be helpful in this quest of learning Python. Resource https://github.com/dloss/python-pentest-tools A great resource to learn more about Python and its usage is the Python docs itself https://docs.python.org/2/ . Another great list of Python-based tools with focus on pentesting is present at https://github.com/dloss/python-pentest-tools . It would be great to create something interesting and useful by modifying, combining, and adding to the mentioned resources. The list is divided into different sections based on the functionality provided by the tool mentioned. So we have covered some basics of Python language and also learned how to extend Maltego framework through it. Through this chapter we have made an attempt to learn about creating own custom tools and modify existing ones in a quick fashion. This chapter is just an introduction of how we can simply create tools with minimum amount of coding. There is certainly room for improvement in the snippets we have shown in functional as well as structural terms, but our aim is to perform the task as quickly as possible. Though we have tried to cover as much ground as possible yet there is so much more to learn when it comes to Python scripting. Python comes with a large set of useful resources and is very powerful; and by using it one can create power toolset, recon-ng ( https://bitbucket.org/LaNMaSteR53/recon-ng ) is great example of it. We have discussed about this Reconnaissance framework in a previous chapter. One great way to take this learning further would be to practice more and create such tools which could be helpful for the community and contribute to the existing ones such as recon-ng. Slowly we are moving toward the end of this journey of learning. We have been through different aspects of intelligence gathering in different manners. Moving on we will be learning about some examples and scenarios related to our endeavor, where we can utilize the knowledge we have gained in a combined form. Show more Read full chapter View PDF Explore book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780128018675000136 Book 2015 , Hacking Web Intelligence Sudhanshu Chauhan , Nutan Kumar Panda Chapter Introduction 2013 , Violent Python TJ O'Connor The Python Language In the following pages, we will tackle the idea of variables, data types, strings, complex data structures, networking, selection, iteration, file handling, exception handling, and interoperability with the operating system. To illustrate this, we will build a simple vulnerability scanner that connects to a TCP socket, reads the banner from a service, and compares that banner against known vulnerable service versions. As an experienced programmer, you may find some of the initial code examples very ugly in design. In fact, hopefully you do. As we continue to develop our script in this section, the script will hopefully grow into an elegant design you can appreciate. Let’s begin by starting with the bedrock of any programming language—variables. Variables In Python, a variable points to data stored in a memory location. This memory location can store different values such as integers, real numbers, Booleans, strings, or more complex data such as lists or dictionaries. In the following code, we define a variable port that stores an integer and banner that stores a string. To combine the two variables together into one string, we must explicitly cast the port as a string using the str() function. >>> port = 21 >>> banner = “FreeFloat FTP Server” >>> print “[+] Checking for “+banner+” on port “+str(port) [+] Checking for FreeFloat FTP Server on port 21 Python reserves memory space for variables when the programmer declares them. The programmer does not have to explicitly declare the type of variable; rather, the Python interpreter decides the type of the variable and how much space in the memory to reserve. Considering the following example, we declare a string, an integer, a list, and a Boolean, and the interpreter correctly automatically types each variable. >>> banner = “FreeFloat FTP Server” # A string >>> type(banner) <type ‘str’> >>> port = 21 # An integer >>> type(port) <type ‘int’> >>> portList=[21,22,80,110] # A list >>> type(portList) <type ‘list’> >>> portOpen = True # A boolean >>> type(portOpen) <type ‘bool’> Strings The Python string module provides a very robust series of methods for strings. Read the Python documentation at http://docs.python.org/library/string .html for the entire list of available methods. Let’s examine a few useful methods. Consider the use of the following methods: upper(), lower(), replace(), and find(). Upper() converts a string to its uppercase variant. Lower() converts a string to its lowercase variant. Replace(old,new) replaces the old occurrence of the substring old with the substring new. Find() reports the offset where the first occurrence of the substring occurs. >>> banner = “FreeFloat FTP Server” >>> print banner.upper() FREEFLOAT FTP SERVER >>> print banner.lower() freefloat ftp server >>> print banner.replace(‘FreeFloat’,’Ability’) Ability FTP Server >>> print banner.find(‘FTP’) 10 Lists The list data structure in Python provides an excellent method for storing arrays of objects in Python. A programmer can construct lists of any data type. Furthermore, built-in methods exist for performing actions such as appending, inserting, removing, popping, indexing, counting, sorting, and reversing lists. Consider the following example: a programmer can construct a list by appending items using the append() method, print the items, and then sort them before printing again. The programmer can find the index of a particular item (the integer 80 in this example). Furthermore, specific items can be removed (the integer 443 in this example). >>> portList = [] >>> portList.append(21) >>> portList.append(80) >>> portList.append(443) >>> portList.append(25) >>> print portList [21, 80, 443, 25] >>> portList.sort() >>> print portList [21, 25, 80, 443] >>> pos = portList.index(80) >>> print “[+] There are “+str(pos)+” ports to scan before 80.” [+] There are 2 ports to scan before 80. >>> portList.remove(443) >>> print portList [21, 25, 80] >>> cnt = len(portList) >>> print “[+] Scanning “+str(cnt)+” Total Ports.” [+] Scanning 3 Total Ports. Dictionaries The Python dictionary data structure provides a hash table that can store any number of Python objects. The dictionary consists of pairs of items that contain a key and value. Let’s continue with our example of a vulnerability scanner to illustrate a Python dictionary. When scanning specific TCP ports, it may prove useful to have a dictionary that contains the common service names for each port. Creating a dictionary, we can lookup a key like ftp and return the associated value 21 for that port. When constructing a dictionary, each key is separated from its value by a colon, and we separate items by commas. Notice that the method .keys() will return a list of all keys in the dictionary and that the method .items() will return an entire list of items in the dictionary. Next, we verify that the dictionary contains a specific key (ftp). Referencing this key returns the value 21. >>> services = {’ftp’:21,’ssh’:22,’smtp’:25,’http’:80} >>> services.keys() [’ftp’, ‘smtp’, ‘ssh’, ‘http’] >>> services.items() [(‘ftp’, 21), (‘smtp’, 25), (‘ssh’, 22), (‘http’, 80)] >>> services.has_key(‘ftp’) True >>> services[’ftp’] 21 >>> print “[+] Found vuln with FTP on port “+str(services[’ftp’]) [+] Found vuln with FTP on port 21 Networking The socket module provides a library for making network connections using Python. Let’s quickly write a banner-grabbing script. Our script will print the banner after connecting to a specific IP address and TCP port. After importing the socket module, we instantiate a new variable s from the class socket class. Next, we use the connect() method to make a network connection to the IP address and port. Once successfully connected, we can read and write from the socket. The recv(1024) method will read the next 1024 bytes on the socket. We store the result of this method in a variable and then print the results to the server. >>> import socket >>> socket.setdefaulttimeout(2) >>> s = socket.socket() >>> s.connect((“192.168.95.148”,21)) >>> ans = s.recv(1024) >>> print ans 220 FreeFloat Ftp Server (Version 1.00). Selection Like most programming languages, Python provides a method for conditional select statements. The IF statement evaluates a logical expression in order to make a decision based on the result of the evaluation. Continuing with our banner-grabbing script, we would like to know if the specific FTP server is vulnerable to attack. To do this, we will compare our results against some known vulnerable FTP server versions. >>> import socket >>> socket.setdefaulttimeout(2) >>> s = socket.socket() >>> s.connect((“192.168.95.148”,21)) >>> ans = s.recv(1024) >>> if (“FreeFloat Ftp Server (Version 1.00)” in ans): ... print “[+] FreeFloat FTP Server is vulnerable.” ... elif (“3Com 3CDaemon FTP Server Version 2.0” in banner): ... print “[+] 3CDaemon FTP Server is vulnerable.” ... elif (“Ability Server 2.34” in banner): ... print “[+] Ability FTP Server is vulnerable.” ... elif (“Sami FTP Server 2.0.2” in banner): ... print “[+] Sami FTP Server is vulnerable.” ... else: ... print “[-] FTP Server is not vulnerable.” ... [+] FreeFloat FTP Server is vulnerable.” Exception Handling Even when a programmer writes a syntactically correct program, the program may still error at runtime or execution. Consider the classic runtime error—division by zero. Because zero cannot divide a number, the Python interpreter displays a message informing the programmer of the error message. This error ceases program execution. >>> print 1337/0 Traceback (most recent call last): File “<stdin>”, line 1, in <module> ZeroDivisionError: integer division or modulo by zero What happens if we just wanted to handle the error within the context of the running program or script? The Python language provides exception-handling capability to do just this. Let’s update the previous example. We use try/except statements to provide exception handling. Now, the program tries to execute the division by zero. When the error occurs, our exception handling catches the error and prints a message to the screen. >>> try: ... print “[+] 1337/0 = “+str(1337/0) ... except: ... print “[-] Error. “ ... [-] Error >>> Unfortunately, this gives us very little information about the exact exception that caused the error. It might be useful to provide the user with an error message about the specific error that occurred. To do this, we will store the exception in a variable e to print the exception, then explicitly cast the variable e as a string. >>> try: ... print “[+] 1337/0 = “+str(1337/0) ... except Exception, e: ... print “[-] Error = “+str(e) ... [-] Error = integer division or modulo by zero >>> Let’s now use exception handling to update our banner-grabbing script. We will wrap the network connection code with exception handling. Next, we try to connect to a machine that is not running a FTP Server on TCP port 21. If we wait for the connection timeout, we see a message indicating the network connection operation timed out. Our program can now continue. >>> import socket >>> socket.setdefaulttimeout(2) >>> s = socket.socket() >>> try: ... s.connect((“192.168.95.149”,21)) ... except Exception, e: ... print “[-] Error = “+str(e) ... [-] Error = Operation timed out Let us provide you one caveat about exception handling in this book. In order to cleanly illustrate the wide variety of concepts in the following pages, we have put minimal exception handling into the scripts in this book. Feel free to update the scripts included on the companion website to add more robust exception handling. Functions In Python, functions provide organized blocks of reusable code. Typically, this allows a programmer to write a block of code to perform a single, related action. While Python provides many built-in functions, a programmer can create user-defined functions. The keyword def() begins a function. The programmer can place any variables inside the parenthesis. These variables are then passed by reference, meaning that any changes to these variables inside the function will affect their value from the calling function. Continuing with the previous FTP vulnerability-scanning example, let’s create a function to perform just the action of connecting to the FTP server and returning the banner. import socket def retBanner(ip, port): try: socket.setdefaulttimeout(2) s = socket.socket() s.connect((ip, port)) banner = s.recv(1024) return banner except: return def main(): ip1 = ‘192.168.95.148’ ip2 = ‘192.168.95.149’ port = 21 banner1 = retBanner(ip1, port) if banner1: print ‘[+] ‘ + ip1 + ‘: ‘ + banner1 banner2 = retBanner(ip2, port) if banner2: print ‘[+] ‘ + ip2 + ‘: ‘ + banner2 if __name__ == ‘__main__’: main() After returning the banner, our script needs to check this banner against some known vulnerable programs. This also reflects a single, related function. The function checkVulns() takes the variable banner as a parameter and then uses it to make a determination of the vulnerability of the server. import socket def retBanner(ip, port): try: socket.setdefaulttimeout(2) s = socket.socket() s.connect((ip, port)) banner = s.recv(1024) return banner except: return def checkVulns(banner): if ‘FreeFloat Ftp Server (Version 1.00)’ in banner: print ‘[+] FreeFloat FTP Server is vulnerable.’ elif ‘3Com 3CDaemon FTP Server Version 2.0’ in banner: print ‘[+] 3CDaemon FTP Server is vulnerable.’ elif ‘Ability Server 2.34’ in banner: print ‘[+] Ability FTP Server is vulnerable.’ elif ‘Sami FTP Server 2.0.2’ in banner: print ‘[+] Sami FTP Server is vulnerable.’ else: print ‘[-] FTP Server is not vulnerable.’ return def main(): ip1 = ‘192.168.95.148’ ip2 = ‘192.168.95.149’ ip3 = ‘192.168.95.150’ port = 21 banner1 = retBanner(ip1, port) if banner1: print ‘[+] ‘ + ip1 + ‘: ‘ + banner1.strip(‘\\n’) checkVulns(banner1) banner2 = retBanner(ip2, port) if banner2: print ‘[+] ‘ + ip2 + ‘: ‘ + banner2.strip(‘\\n’) checkVulns(banner2) banner3 = retBanner(ip3, port) if banner3: print ‘[+] ‘ + ip3 + ‘: ‘ + banner3.strip(‘\\n’) checkVulns(banner3) if __name__ == ‘__main__’: main() Iteration During the last section, you might have found it repetitive to write almost the same exact code three times to check the three different IP addresses. Instead of writing the same thing three times, we might find it easier to use a for-loop to iterate through multiple elements. Consider, for example: if we wanted to iterate through the entire /24 subnet of IP addresses for 192.168.95.1 through 192.168.95.254, using a for-loop with the range from 1 to 255 allows us to print out the entire subnet. >>> for x in range(1,255): ... print “192.168.95.”+str(x) ... 192.168.95.1 192.168.95.2 192.168.95.3 192.168.95.4 192.168.95.5 192.168.95.6 ... <SNIPPED> ... 192.168.95.253 192.168.95.254 Similarly, we may want to iterate through a known list of ports to check for vulnerabilities. Instead of iterating through a range of numbers, we can iterate through an entire list of elements. >>> portList = [21,22,25,80,110] >>> for port in portList: ... print port ... 21 22 25 80 110 Nesting our two for-loops, we can now print out each IP address and the ports for each address. >>> for x in range(1,255): ... for port in portList: ... print “[+] Checking 192.168.95.”\\ +str(x)+”: “+str(port) ... [+] Checking 192.168.95.1:21 [+] Checking 192.168.95.1:22 [+] Checking 192.168.95.1:25 [+] Checking 192.168.95.1:80 [+] Checking 192.168.95.1:110 [+] Checking 192.168.95.2:21 [+] Checking 192.168.95.2:22 [+] Checking 192.168.95.2:25 [+] Checking 192.168.95.2:80 [+] Checking 192.168.95.2:110 <... SNIPPED ...> With the ability to iterate through IP addresses and ports, we will update our vulnerability-checking script. Now our script will test all 254 IP addresses on the 192.168.95.0/24 subnet with the ports offering telnet, SSH, smtp, http, imap, and https services. import socket def retBanner(ip, port): try: socket.setdefaulttimeout(2) s = socket.socket() s.connect((ip, port)) banner = s.recv(1024) return banner except: return def checkVulns(banner): if ‘FreeFloat Ftp Server (Version 1.00)’ in banner: print ‘[+] FreeFloat FTP Server is vulnerable.’ elif ‘3Com 3CDaemon FTP Server Version 2.0’ in banner: print ‘[+] 3CDaemon FTP Server is vulnerable.’ elif ‘Ability Server 2.34’ in banner: print ‘[+] Ability FTP Server is vulnerable.’ elif ‘Sami FTP Server 2.0.2’ in banner: print ‘[+] Sami FTP Server is vulnerable.’ else: print ‘[-] FTP Server is not vulnerable.’ return def main(): portList = [21,22,25,80,110,443] for x in range(1, 255): ip = ‘192.168.95.’ + str(x) for port in portList: banner = retBanner(ip, port) if banner: print ‘[+] ‘ + ip + ‘: ‘ + banner checkVulns(banner) if __name__ == ‘__main__’: main() File I/O While our script has an IF statement that checks a few vulnerable banners, it would be nice to occasionally add a new list of vulnerable banners. For this example, let’s assume we have a text file called vuln_banners.txt. Each line in this file lists a specific service version with a previous vulnerability. Instead of constructing a huge IF statement, let’s read in this text file and use it to make decisions if our banner is vulnerable. programmer$ cat vuln_banners.txt 3Com 3CDaemon FTP Server Version 2.0 Ability Server 2.34 CCProxy Telnet Service Ready ESMTP TABS Mail Server for Windows NT FreeFloat Ftp Server (Version 1.00) IMAP4rev1 MDaemon 9.6.4 ready MailEnable Service, Version: 0-1.54 NetDecision-HTTP-Server 1.0 PSO Proxy 0.9 SAMBAR Sami FTP Server 2.0.2 Spipe 1.0 TelSrv 1.5 WDaemon 6.8.5 WinGate 6.1.1 Xitami YahooPOPs! Simple Mail Transfer Service Ready We will place our updated code in the checkVulns function. Here, we will open the text file in read-only mode (‘r’). We iterate through each line in the file using the method .readlines(). For each line, we compare it against our banner. Notice that we must strip out the carriage return from each line using the method .strip(‘\\r’). If we detect a match, we print the vulnerable service banner. def checkVulns(banner): f = open(“vuln_banners.txt”,’r’) for line in f.readlines(): if line.strip(‘\\n’) in banner: print “[+] Server is vulnerable: “+banner.strip(‘\\n’) Sys Module The built-in sys module provides access to objects used or maintained by the Python interpreter. This includes flags, version, max sizes of integers, available modules, path hooks, location of standard error/in/out, and command line arguments called by the interpreter. You can find more information on the Python online module documents available from http://docs.python.org/library/sys . Interacting with the sys module can prove very helpful in creating Python scripts. We may, for example, want to parse command line arguments at runtime. Consider our vulnerability scanner: what if we wanted to pass the name of a text file as a command line argument? The list sys.argv contains all the command line arguments. The first index sys.argv[0] contains the name of the interpreter Python script. The remaining items in the list contain all the following command line arguments. Thus, if we are only passing one additional argument, sys.argv should contain two items. import sys if len(sys.argv)==2: filename = sys.argv[1] print “[+] Reading Vulnerabilities From: “+filename Running our code snippet, we see that the code successfully parses the command line argument and prints it to the screen. Take the time to examine the entire sys module for the wealth of capabilities it provides to the programmer. programmer$ python vuln-scanner.py vuln-banners.txt [+] Reading Vulnerabilities From: vuln-banners.txt OS Module The built-in OS module provides a wealth of OS routines for Mac, NT, or Posix operating systems. This module allows the program to independently interact with the OS environment, file-system, user database, and permissions. Consider, for example, the last section, where the user passed the name of a text file as a command line argument. It might prove valuable to check to see if that file exists and the current user has read permissions to that file. If either condition fails, it would be useful to display an appropriate error message to the user. import sys import os if len(sys.argv) == 2: filename = sys.argv[1] if not os.path.isfile(filename): print ‘[-] ‘ + filename + ‘ does not exist.’ exit(0) if not os.access(filename, os.R_OK): print ‘[-] ‘ + filename + ‘ access denied.’ exit(0) print ‘[+] Reading Vulnerabilities From: ‘ + filename To verify our code, we initially try to read a file that does not exist, which causes our script to print an error. Next, we create the specific filename and successfully read it. Finally, we restrict permission and see that our script correctly prints the access-denied message. programmer$ python test.py vuln-banners.txt [-] vuln-banners.txt does not exist. programmer$ touch vuln-banners.txt programmer$ python test.py vuln-banners.txt [+] Reading Vulnerabilities From: vuln-banners.txt programmer$ chmod 000 vuln-banners.txt programmer$ python test.py vuln-banners.txt [-] vuln-banners.txt access denied. We can now reassemble all the various pieces and parts of our Python vulnerability-scanning script. Do not worry if it appears pseudo-complete, lacking the ability to use threads of execution or better command line option parsing. We will continue to build upon this script in the following chapter. Import socket import os import sys def retBanner(ip, port): try: socket.setdefaulttimeout(2) s = socket.socket() s.connect((ip, port)) banner = s.recv(1024) return banner except: return def checkVulns(banner, filename): f = open(filename, ‘r’) for line in f.readlines(): if line.strip(‘\\n’) in banner: print ‘[+] Server is vulnerable: ‘ +\\ banner.strip(‘\\n’) def main(): if len(sys.argv) == 2: filename = sys.argv[1] if not os.path.isfile(filename): print ‘[-] ‘ + filename +\\ ‘ does not exist.’ exit(0) if not os.access(filename, os.R_OK): print ‘[-] ‘ + filename +\\ ‘ access denied.’ exit(0) else: print ‘[-] Usage: ‘ + str(sys.argv[0]) +\\ ‘ <vuln filename>’ exit(0) portList = [21,22,25,80,110,443] for x in range(147, 150): ip = ‘192.168.95.’ + str(x) for port in portList: banner = retBanner(ip, port) if banner: print ‘[+] ‘ + ip + ‘: ‘ + banner checkVulns(banner, filename) if __name__ == ‘__main__’: main() Show more Read full chapter View PDF Explore book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9781597499576000016 Book 2013 , Violent Python TJ O'Connor Chapter Looking Ahead 2014 , Python Forensics Chet Hosmer Abstract In this chapter, I outline some history along with the future outlook for the Python language , along with the potential positive impacts on the future of digital investigation and forensics. Show more Read full chapter View PDF Explore book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780124186767000128 Book 2014 , Python Forensics Chet Hosmer Chapter Introduction to Python 2017 , Coding for Penetration Testers (Second Edition) Jason Andress , Ryan Linn Abstract In this chapter, we dig into the Python language and investigate different types of network scripts, subnetting, and file manipulation. These topics are investigated through practical examples that we will encounter while penetration testing. We look at how to build scripts to communicate with Web servers, determine what Web servers may be hiding, and even investigate how to send our data without it being seen by network tools. These examples and more provide practical, real-world scenarios for when and how to use the Python language. While we’re building tools that we can extend for our scripting toolkit, we investigate all the Python basics from data structures, to control statements, to interact with the shell, and to manipulate strings and files. Show more Read full chapter View PDF Explore book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780128054727000024 Book 2017 , Coding for Penetration Testers (Second Edition) Jason Andress , Ryan Linn Chapter Looking Ahead 2014 , Python Forensics Chet Hosmer Conclusion Applying the Python language to digital investigation and forensic applications has great promise. What is needed is a collaborative community that includes: practitioners, researchers, developers, professors, students, investigators, examiners, detectives, attorneys, prosecutors, judges, vendors, governments, and research institutes. In addition, a cloud-based computing platform with thousands of cores, petabytes of storage, and terabytes of memory is necessary. I challenge you to participate. If everyone reading this book would submit one idea, challenge problem or solution that would be a tremendous start. Visit Python-Forensics.Org to get started…. I would love to hear from you! Show more Read full chapter View PDF Explore book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780124186767000128 Book 2014 , Python Forensics Chet Hosmer Chapter Forensic Searching and Indexing Using Python 2014 , Python Forensics Chet Hosmer Chapter review In this chapter, I put to use new Python language elements including sets and bytearray s and I expanded the use of lists and classes. I also provided examples of how to open and read files containing a diverse set of values such as keywords, raw binary, and hexadecimal values and work with those directly within Python bytearrays, lists, and sets. I demonstrated how leveraging the right language elements can lead to simple, readable code that accomplishes our objectives. As a result, p-search is a useable application that provides investigators with the capability to search for keywords and generate an index of words found in documents, disk images, memory snapshots, and even network traces. In addition, I once again demonstrated the interoperability of Python code by running the sample unaltered code on Windows, Linux, and Mac producing the same results. Show more Read full chapter View PDF Explore book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780124186767000049 Book 2014 , Python Forensics Chet Hosmer Chapter Setting up a Python Forensics Environment 2014 , Python Forensics Chet Hosmer iOS Python app Python for iOS is the version that I find most stable and supported for iPad. In Figure 2.36 , you can see an image of the Python 2.7 Shell running on iOS, just printing out the similar Hello World message. The Shell and editor have some great features that allow you to experiment with the Python language syntax and modules. Figure 2.36 . Python Shell running on iOS. The capability is actually quite a bit better than this simple example. I imported one of the earlier examples that performs a SHA256 Hash of a string. At the top of the short program I added a couple of new methods, one contained in the Standard Library module sys and one in the Standard Library module platform . I imported the two modules and wrote the following code. import sys import platform print(“Platform: “+sys.platform) print(“Machine: “+platform.machine()) You can see the results of these new methods and the program in Figure 2.37 . You notice that Platform is defined as Darwin and the Machine is identified as an iPad version 1. Correct in both cases. Darwin is the platform name specified by Apple for Mac OS X and of course the machine is my old and still faithful iPad 1. Figure 2.37 . iOS implementation of HashPrint. For those interested in checking out this iOS application from the Apple App Store, Figure 2.38 is a screenshot from the Store with more details about Python for iOS. Figure 2.38 . Apple App Store page regarding Python for iOS. Show more Read full chapter View PDF Explore book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780124186767000025 Book 2014 , Python Forensics Chet Hosmer Chapter Why Python Forensics? 2014 , Python Forensics Chet Hosmer How can the Python programming environment help meet these challenges? Creating an environment where social and computer scientists can collaborate and work together is challenging. Creating a platform to develop new technology-based solutions that address the broad range of digital investigation challenges outlined earlier in this chapter is difficult. Doing them both together is a real challenge, and whenever you take on a challenge like this it is important to consider the underpinnings so that you create the best chance for success. I personally have a few important considerations that have served me well over the years, so I will share them with you here. 1. Does the platform you are building on have broad industry support? 2. Is there an ample supply of technical data regarding the subject along with a large cadre of talent or subject matter experts? 3. Is the technology platform you are considering open or closed? 4. Where does the technology exist along its lifecycle (i.e., too early, too late or mature, and evolving)? 5. What is the cost or other barriers to entry? (especially if you are trying to attract a broad array of participants) 6. Finally, since we are trying to bridge the gap between social and computer science, is the environment well suited for cross-disciplinary collaboration? Global support for Python Python was created by Guido van Russom in the late 1980s with the fundamental premise that Python is programming for everyone. This has created a groundswell of support from a broad array of domain-specific researchers, the general software development community, and programmers with varying backgrounds and abilities. The Python language is both general purpose and produces easily readable code that can be understood by nonprogrammers. In addition, due to Python’s intrinsic extensibility, copious amount of third-party libraries and modules exist. Numerous web sites provide tips, tricks, coding examples, and training for those needing a deeper dive into the language. It may surprise you that Python was ranked as the number 1 programming language in 2013 by codeeval.com (see Figure 1.5 ) edging out Java for the first time. A great place to start is at the official Python programming language web sites python.org . Figure 1.5 . Programming language popularity according to codeview.com . Finally, sophisticated integrated software development environments exist that allow even the novice developer to innovate new ideas and design, and then build and test their inventions and prototypes. Python is an interpreted language; however, compilers are available as well, of course. As shown in Figure 1.6 , developers have adopted the test-then code-then validate mindset. Figure 1.6 . Test-then code-then validate. By utilizing the Python Shell, experienced and novice users alike can experiment with the language, libraries, modules, and data structures before attempting to integrate them into a complete program or application. This promotes experimentation with the language, language constructs, objects, experimentation with performance considerations, and libraries, and allows users to explore and tradeoff approaches prior to putting them into practice. Once confident with the use, characteristics and behaviors of the language, the integration into working programs tends to go more smoothly. In addition, this experimentation often leads to testing considerations that can then be applied to the working programs once they have been completed, thus completing the cycle of test-code-validate. Open source and platform independence Since Python is an open source environment, developers continue to create compatible versions that run across multiple platforms. Python implementations exist for today’s most popular platforms including Windows, Linux, and Mac OS X as you would expect. However, the support for Python is much broader. Support for mobile device operating systems such as Android, iOS, and Windows 8 is also available. In addition, Python is supported on platforms that you might not expect such as AIX, AS/400, VMS, Solaris, PalmOS, OS/2, and HP-UX, just to mention a few. What this means for cybercrime investigators is portability of these applications for today’s platforms, yesterday’s platforms, and future platforms. In March 2013, NVIDIA announced support for Python developers by opening the door to GPU-Accelerated Computing using NVIDIA CUDA, allowing for parallel processing capabilities, and advancing the performance of virtually any Python-developed application. This will deliver the ability to handle and process big data, perform advanced analytical operations, perform deductive and inductive reasoning, and meet future computational challenges. This versatility ensures that the investment made in creating new investigative solutions will be useable and sharable with colleagues that use different flavors of computing platforms. Lifecycle positioning Python today sits in the best position possible to be leveraged for investigative applications. The language is mature, hundreds of thousands of developers are experienced, a strong support organization is in place, extensible libraries are plentiful, applications are portable to a wide range of computing platforms, the source code is open and free, and new innovations to the core language are keeping pace with hardware and operating system advancements. Cost and barriers to entry One of the keys to Python’s success is the lack of virtually any barrier to entry. The development environment is free, the language is platform independent, the code is as easy to read and write as English, and support is vast and worldwide. In my opinion, it should revolutionize the development of new cybercrime, forensic, and incident response-based solutions. The key is to develop outreach that will encourage, attract, and open the doors to social scientists, computer scientists, law enforcement organizations, forensic labs, standards bodies, incident response teams, academics, students, and virtually anyone with domain expertise within the broadest definition of cybercrime. Show more Read full chapter View PDF Explore book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780124186767000013 Book 2014 , Python Forensics Chet Hosmer Related terms: Artificial Intelligence Information System Pattern Recognition Machine Learning Reinforcement Learning Internet of Things Software Defined Networking Graphical User Interface Blockchain acoustic emission signal View all Topics"
}