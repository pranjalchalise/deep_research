{
  "metadata": {
    "key": "search:general:10:detailed information about langchain's new fratures",
    "created": 1770002814.906084,
    "ttl": 86400
  },
  "data": [
    {
      "url": "https://docs.langchain.com/oss/javascript/releases/changelog",
      "title": "Changelog - Docs by LangChain",
      "snippet": "### ‚Äã\n\nNew state value primitives\n\n   ReducedValue: Define fields with custom reducers for accumulating values. Supports separate input and output schemas for type-safe reducer inputs.\n   UntrackedValue: Define transient state that exists during execution but is never checkpointed - useful for database connections, caches, or runtime-only configuration.\n   MessagesValue: A prebuilt `ReducedValue` for chat messages with the standard messages reducer.\n\n### ‚Äã\n\nType helper exports\n\nNew exported type utilities for typing functions outside the graph builder:\n   `GraphNode<Schema, Nodes?, Config?>` - Type node functions with full inference\n   `ConditionalEdgeRouter<Schema, Nodes?>` - Type conditional edge routers\n\nCopy [...] Structured output: `ProviderStrategy` support (native structured output) can now be inferred from model profiles.\n   `SystemMessage` for `createAgent`: Support for passing `SystemMessage` instances directly to `createAgent`‚Äôs `systemPrompt` parameter and a new `concat` method for extending system messages. Enables advanced features like cache control and structured content blocks.\n   Dynamic system prompt middleware: Return values from `dynamicSystemPromptMiddleware` are now purely additive. When returning a `SystemMessage` or `string`, they are merged with existing system messages rather than replacing them, making it easier to compose multiple middleware that modify the prompt. [...] ‚Äã\n\nDec 12, 2025\n\nlangchain@langchain/openai@langchain/anthropic@langchain/ollama@langchain/community@langchain/xai@langchain/tavily@langchain/mongodb@langchain/mcp-adapters@langchain/google-common@langchain/core\n\n‚Äã\n\nv1.2.0\n\n### ‚Äã\n\n`langchain`\n\n   Structured output: Added ability to manually set `strict` mode when using `providerStrategy` for structured output.\n\n### ‚Äã\n\n`@langchain/openai`\n\n   New provider built-in tools: Support for file search, web search, code interpreter, image generation, computer use, shell, and MCP connector tools.\n   Content moderation: New `moderateContent` option on `ChatOpenAI` for detecting and handling unsafe content.\n   Prefer responses API for GPT-5.2 Pro model.\n\n‚Äã\n\nv1.3.0\n\n### ‚Äã\n\n`@langchain/anthropic`"
    },
    {
      "url": "https://docs.langchain.com/oss/python/releases/changelog",
      "title": "Changelog - Docs by LangChain",
      "snippet": "Model profiles: Chat models now expose supported features and capabilities through a `.profile` attribute. These data are derived from models.dev, an open source project providing model capability data.\n   Summarization middleware: Updated to support flexible trigger points using model profiles for context-aware summarization.\n   Structured output: `ProviderStrategy` support (native structured output) can now be inferred from model profiles.\n   `SystemMessage` for `create_agent`: Support for passing `SystemMessage` instances directly to `create_agent`‚Äôs `system_prompt` parameter, enabling advanced features like cache control and structured content blocks.\n   Model retry middleware: New middleware for automatically retrying failed model calls with configurable exponential backoff. [...] Copy page\n\nSubscribe: Our changelog includes an RSS feed that can integrate with Slack, email, Discord bots like Readybot or RSS Feeds to Discord Bot, and other subscription tools.\n\n‚Äã\n\nDec 15, 2025\n\nlangchain integrations\n\n‚Äã\n\n`langchain` v1.2.0\n\n   `create_agent`: Simplified support for provider-specific tool parameters and definitions via a new `extras` attribute on tools. Examples: \n       Provider-specific configuration such as Anthropic‚Äôs programmatic tool calling and tool search.\n       Built-in tools that are executed client-side, as supported by Anthropic, OpenAI, and other providers.\n\n   Support for strict schema-adherence in agent `response_format` (see `ProviderStrategy` docs).\n\n‚Äã\n\nDec 8, 2025\n\nlangchain integrations\n\n‚Äã\n\n`langchain-google-genai` v4.0.0 [...] ‚Äã\n\nOct 20, 2025\n\nlangchain langgraph\n\n‚Äã\n\nv1.0.0\n\n### ‚Äã\n\n`langchain`\n\n   Release notes\n   Migration guide\n\n### ‚Äã\n\n`langgraph`\n\n   Release notes\n   Migration guide\n\nIf you encounter any issues or have feedback, please open an issue so we can improve. To view v0.x documentation, go to the archived content and API reference.\n\n  \n\nEdit this page on GitHub or file an issue.\n\nConnect these docs to Claude, VSCode, and more via MCP for real-time answers.\n\nWas this page helpful?\n\nYes No\n\nVersioning PreviousWhat's new in LangChain v1 Next\n\nCtrl+I\n\nDocs by LangChain home pageImage 3: light logoImage 4: dark logo\n\ngithubxlinkedinyoutube\n\nResources\n\nForumChangelogLangChain AcademyTrust Center\n\nCompany\n\nAboutCareersBlog\n\ngithubxlinkedinyoutube\n\nPowered by\n\nAssistant"
    },
    {
      "url": "https://latenode.com/blog/ai-frameworks-technical-infrastructure/langchain-setup-tools-agents-memory/langchain-framework-2025-complete-features-guide-real-world-use-cases-for-developers",
      "title": "LangChain Framework 2025: Complete Features Guide ...",
      "snippet": "One practical application is automated testing systems. LangChain can analyze codebases, understand function signatures, and generate extensive test suites. Its ability to maintain context across multiple files makes it particularly effective for large-scale test generation.\n\nCode review automation is another area where LangChain shines. These tools analyze code changes, identify potential issues, suggest improvements, and ensure adherence to coding standards. For example, they can review pull requests and provide detailed feedback in natural language. [...] Research and analysis tools also leverage LangChain's chain-based approach for multi-step reasoning. Tasks like document retrieval, relevance scoring, content summarization, and insight generation are effectively managed. However, LangChain's abstraction layers can introduce latency, making it less suitable for real-time applications that require sub-second response times. In such scenarios, direct vector database queries often provide better performance.\n\nLangChain's agent frameworks take these capabilities a step further by automating workflows.\n\n### Workflow Automation and Multi-Agent Systems\n\nLangChain's agent frameworks support complex workflows by enabling multiple AI agents to collaborate on tasks that require dynamic decision-making and tool integration. [...] Debugging within LangChain‚Äôs modular framework can also be challenging. Errors often originate deep within its abstractions, providing limited visibility into the root cause. Furthermore, documentation updates may lag behind new features, leaving developers dependent on source code reviews or community forums for troubleshooting.\n\nMonitoring production deployments is another hurdle. Standard logging and monitoring tools may not fully capture the internal workings of LangChain‚Äôs chains or memory components. Teams often need to create custom monitoring solutions to track performance and reliability effectively."
    },
    {
      "url": "https://docs.langchain.com/oss/python/releases/langchain-v1",
      "title": "What's new in LangChain v1",
      "snippet": "create_agent ------------ The new standard for building agents in LangChain, replacing `langgraph.prebuilt.create_react_agent`.Standard content blocks ----------------------- A new `content_blocks` property that provides unified access to modern LLM features across providers.Simplified namespace -------------------- The `langchain` namespace has been streamlined to focus on essential building blocks for agents, with legacy functionality moved to `langchain-classic`.\n\nTo upgrade,\n\npip\n\nuv\n\nCopy\n\n```\npip install -U langchain\n```\n\nFor a complete list of changes, see the migration guide.\n‚Äã\n\n`create_agent` [...] ‚Äã\n\nSimplified package\n\nLangChain v1 streamlines the `langchain` package namespace to focus on essential building blocks for agents. The refined namespace exposes the most useful and relevant functionality:\n### ‚Äã\n\nNamespace\n\n| Module | What‚Äôs available | Notes |\n --- \n| `langchain.agents` | `create_agent`, `AgentState` | Core agent creation functionality |\n| `langchain.messages` | Message types, content blocks, `trim_messages` | Re-exported from `langchain-core` |\n| `langchain.tools` | `@tool`, `BaseTool`, injection helpers | Re-exported from `langchain-core` |\n| `langchain.chat_models` | `init_chat_model`, `BaseChatModel` | Unified model initialization |\n| `langchain.embeddings` | `Embeddings`, `init_embeddings` | Embedding models | [...] Prebuilt middleware\n\nLangChain provides a few prebuilt middlewares for common patterns, including:\n   `PIIMiddleware`: Redact sensitive information before sending to the model\n   `SummarizationMiddleware`: Condense conversation history when it gets too long\n   `HumanInTheLoopMiddleware`: Require approval for sensitive tool calls\n\nCopy\n\n```\nfrom langchain.agents import create_agent\nfrom langchain.agents.middleware import (\n    PIIMiddleware,\n    SummarizationMiddleware,\n    HumanInTheLoopMiddleware\n)"
    },
    {
      "url": "https://docs.langchain.com/oss/javascript/releases/langchain-v1",
      "title": "What's new in LangChain v1",
      "snippet": "createAgent ----------- A new standard way to build agents in LangChain, replacing `createReactAgent` from LangGraph with a cleaner, more powerful API.Standard content blocks ----------------------- A new `contentBlocks` property that provides unified access to modern LLM features across all providers.Simplified package ------------------ The `langchain` package has been streamlined to focus on essential building blocks for agents, with legacy functionality moved to `@langchain/classic`.\n\nTo upgrade,\n\nnpm\n\npnpm\n\nyarn\n\nbun\n\nCopy\n\n```\nnpm install langchain @langchain/core\n```\n\nFor a complete list of changes, see the migration guide.\n‚Äã\n\n`createAgent` [...] Prebuilt middleware\n\nLangChain provides a few prebuilt middlewares for common patterns, including:\n   `summarizationMiddleware`: Condense conversation history when it gets too long\n   `humanInTheLoopMiddleware`: Require approval for sensitive tool calls\n   `piiRedactionMiddleware`: Redact sensitive information before sending to the model\n\nCopy\n\n```\nimport {\n  createAgent,\n  summarizationMiddleware,\n  humanInTheLoopMiddleware,\n  piiRedactionMiddleware,\n} from \"langchain\"; [...] ### ‚Äã\n\nBenefits\n\n   Provider agnostic: Access reasoning traces, citations, built-in tools (web search, code interpreters, etc.), and other features using the same API regardless of provider\n   Type safe: Full type hints for all content block types\n   Backward compatible: Standard content can be loaded lazily, so there are no associated breaking changes\n\nFor more information, see our guide on content blocks\n\n  \n\n‚Äã\n\nSimplified package\n\nLangChain v1 streamlines the `langchain` package namespace to focus on essential building blocks for agents. The package exposes only the most useful and relevant functionality:Most of these are re-exported from `@langchain/core` for convenience, which gives you a focused API surface for building agents.\n### ‚Äã\n\n`@langchain/classic`"
    },
    {
      "url": "https://medium.com/mitb-for-all/langchain-a-second-look-6ed720e27fec",
      "title": "LangChain 1.0 ‚Äî A second look",
      "snippet": "LangChain 1.0 is a vast improvement over the 0.3 LangChain frameworks ‚Äî it is a comprehensive rewrite with many new, meaningful features. LangGraph 1.0 is a modest yet meaningful improvement, deliberately re-designed to fit better with LangChain 1.0.\n\nTo keep this article digestible, I‚Äôll cover only the meaningful improvements (there are many) of the LangChain 1.0 framework. I‚Äôll probably cover the LangGraph 1.0 framework in a separate article.\n\nAs always, all codes can be found in my GitHub repository.\n\n## TLDR: The core changes at a high level\n\nI‚Äôve identified two main core changes:\n\n### Context engineering [...] Sitemap\n\nOpen in app\n\nSign in\n\nSign in\n\n## MITB For All\n\nTech contents related to AI, Analytics, Fintech, and Digital Transformation. Written by MITB Alumni; open-access for everyone.\n\n# LangChain 1.0 ‚Äî A second look\n\n## Rewriting how developers think about context in LLM orchestration\n\nTituslhy\n\n15 min read\n\n¬∑\n\nOct 25, 2025\n\n--\n\nIn September 2025 the world stood still for a minute: LangChain announced a major rewrite of the LangChain and LangGraph frameworks. Instead of version 0.3, both frameworks are now 1.0. [...] ### Context engineering\n\nLangChain 1.0 has put context engineering front and center of its consideration with the `middleware` abstractions. These abstractions are honestly very fun to use and make it easier for developers to better ensure context quarantine and prevent context pollution ‚Äî extracting the best performance out of your agents.\n\n### The developer experience:\n\nGoodbye LCEL (LangChain Expression Language) runnables with pipes ‚Äî I won‚Äôt miss you. Apps that have many ‚Äú|‚Äù operators (`prompt | llm | StrOutputParser()`)are no longer a thing ‚Äî thank goodness. LangChain 1.0 is no longer a low-level framework but a low-mid level framework. This means the learning curve and developer speeds are much better.\n\nOh, and the docs improved as well.\n\n## The LLM"
    },
    {
      "url": "https://docs.aws.amazon.com/prescriptive-guidance/latest/agentic-ai-frameworks/langchain-langgraph.html",
      "title": "LangChain and LangGraph - AWS Prescriptive Guidance",
      "snippet": "## Implementation approach for LangChain and LangGraph\n\nLangChain and LangGraph provide a structured implementation approach for business stakeholders, as detailed in the LangGraph documentation. The framework enables organizations to:\n\n Define sophisticated workflow graphs that represent business processes.\n Create multi-step reasoning patterns with decision points and conditional logic.\n Integrate multimodal processing capabilities for handling diverse data types.\n Implement quality control through built-in review and validation mechanisms.\n\nThis graph-based approach allows business teams to model complex decision processes as autonomous workflows. Teams have clear visibility into each step of the reasoning process and the ability to audit decision paths. [...] Component ecosystem ‚Äì Extensive library of pre-built components for various autonomous agent capabilities, enabling rapid development of specialized agents. For more information, see Quickstart in the LangChain documentation.\n Foundation model selection ‚Äì Support for diverse foundation models including Anthropic Claude, Amazon Nova models (Premier, Pro, Lite, and Micro) on Amazon Bedrock, and others for different reasoning capabilities. For more information, see Inputs and outputs in the LangChain documentation.\n LLM API integration ‚Äì Standardized interfaces for multiple large language model (LLM) service providers including Amazon Bedrock, OpenAI, and others for flexible deployment. For more information, see LLMs in the LangChain documentation. [...] Multimodal processing ‚Äì Built-in support for text, image, and audio processing to enable rich multimodal autonomous agent interactions. For more information, see Multimodality in the LangChain documentation.\n Graph-based workflows ‚Äì LangGraph enables defining complex autonomous agent behaviors as state machines, supporting sophisticated decision logic. For more information, see the LangGraph Platform GA announcement.\n Memory abstractions ‚Äì Multiple options for short and long-term memory management, which is essential for autonomous agents that maintain context over time. For more information, see How to add memory to chatbots in the LangChain documentation."
    },
    {
      "url": "https://github.com/langchain-ai/langchain",
      "title": "langchain-ai/langchain: ü¶úüîó The platform for reliable agents.",
      "snippet": "| .vscode | .vscode | chore(infra): remove jupyter recommended extensions (: remove jupyter recommended extensions (#34430)\")#34430): remove jupyter recommended extensions (#34430)\") | Dec 20, 2025 |\n| libs | libs | fix(core): google docstring parsing with no arguments/reserved argume‚Ä¶: google docstring parsing with no arguments/reserved arguments (#34861)\") | Jan 31, 2026 |\n| .dockerignore | .dockerignore | feat(infra): add: add `.dockerignore` for codespaces (#34533)\")`.dockerignore`for codespaces (: add `.dockerignore` for codespaces (#34533)\")#34533): add `.dockerignore` for codespaces (#34533)\") | Dec 29, 2025 |\n| .editorconfig | .editorconfig | chore: add .editorconfig for consistent coding styles across files ( Following existing codebase conventions\")#‚Ä¶ | Jul 28, 2025 | [...] | CONTRIBUTING.md | CONTRIBUTING.md | docs: add CONTRIBUTING.md pointing to online guide (\")#34901)\") | Jan 30, 2026 |\n| LICENSE | LICENSE | Library Licenses ( Same change as #8403 but in other libs also updates (c) LangChain Inc. instead of @hwchase17\")#13300) Same change as #8403 but in other libs also updates (c) LangChain Inc. instead of @hwchase17\") | Nov 29, 2023 |\n| README.md | README.md | docs: add Chat LangChain link and highlight Deep Agents (\")#34858)\") | Jan 23, 2026 |\n| View all files | [...] | .mcp.json | .mcp.json | feat(infra): langchain docs MCP (: langchain docs MCP (#33636)\")#33636): langchain docs MCP (#33636)\") | Oct 22, 2025 |\n| .pre-commit-config.yaml | .pre-commit-config.yaml | chore(core, langchain): add version consistency check pre-commit hooks (: add version consistency check pre-commit hooks (#34782)\") | Jan 16, 2026 |"
    },
    {
      "url": "https://sider.ai/blog/ai-tools/is-langchain-still-worth-it-a-2025-review-of-features-limits-and-real-world-fit",
      "title": "Is LangChain Still Worth It? A 2025 Review of Features, ...",
      "snippet": "## What is LangChain in 2025?\n\nLangChain is an open‚Äësource framework for building LLM applications with composable primitives‚Äîprompts, models, memory, tools, retrievers‚Äîand higher‚Äëlevel patterns like chains, agents, and graphs. In 2025, it remains a top‚Äëof‚Äëmind choice for developers because of its:\n\n Huge integration surface (vector DBs, model providers, document loaders)\n\n Agent/tooling ecosystem (tools, tool calling, function schemas)\n\n RAG support (retrievers, post‚Äëprocessors, evaluators)\n\n LangGraph for stateful, multi‚Äëstep agent workflows [...] ### Pattern 1: Deterministic RAG with guardrails\n\n Use LangChain retrievers + rerankers.\n\n Constrain outputs via JSON schema; add factuality checks on citations.\n\n Cache frequent queries; add batch evaluation jobs.\n\n### Pattern 2: Tool‚Äëusing agent with LangGraph\n\n Split tasks into nodes: planning ‚Üí retrieval ‚Üí tool invocation ‚Üí synthesis.\n\n Timebox or step‚Äëlimit loops; log state for debuggability.\n\n Add a fallback chain for graceful degradation (e.g., summary without tools).\n\n### Pattern 3: Hybrid search for enterprise knowledge\n\n Pair keyword search (BM25) with dense retrieval.\n\n Maintain a changelog-based ingestion job to refresh embeddings.\n\n Add PII filters and role‚Äëbased access in the retriever layer.\n\n## Developer experience tips [...] ### 4) Opinionated defaults\n\n Great for speed, but you might outgrow the defaults, leading to custom layers that sidestep LangChain‚Äôs abstractions.\n\n## Feature deep dive: What‚Äôs new and notable\n\n### LangGraph for structured agents\n\n Model multi‚Äëstep reasoning with explicit nodes, edges, and state.\n\n Better for reliability than unconstrained tool‚Äëcalling loops.\n\n Pairs well with serverless or containerized deployments where steps are observable.\n\n### RAG enhancements\n\n Easier experimentation with chunking, hybrid retrieval, reranking.\n\n Better evaluator support (hallucination checks, grounding tests) to productionize RAG.\n\n### Tooling and structured outputs\n\n Improved JSON schema adherence, function‚Äëcalling alignment across providers."
    },
    {
      "url": "https://focused.io/lab/langchain-under-the-hood-5-features-we-rely-on-daily",
      "title": "LangChain Under the Hood: 5 Features We Rely On Daily",
      "snippet": "To do this, we create a RunnablePassthrough object that passes the user input to the retriever which retrieves the context data and formats it before finally injecting the resulting content into our prompt template‚Äôs context variable.\n\nWith the abstractions LangChain provides, RAG functionality can be achieved easily without the need for fussing over the nuances of integrating with one vector store vs another or planning an intensive migration if, or more likely when, you decide that you want to try out the hot new vector database. [...] To do this, we create a RunnablePassthrough object that passes the user input to the retriever which retrieves the context data and formats it before finally injecting the resulting content into our prompt template‚Äôs context variable.\n\nWith the abstractions LangChain provides, RAG functionality can be achieved easily without the need for fussing over the nuances of integrating with one vector store vs another or planning an intensive migration if, or more likely when, you decide that you want to try out the hot new vector database. [...] To do this, we create a RunnablePassthrough object that passes the user input to the retriever which retrieves the context data and formats it before finally injecting the resulting content into our prompt template‚Äôs context variable.\n\nWith the abstractions LangChain provides, RAG functionality can be achieved easily without the need for fussing over the nuances of integrating with one vector store vs another or planning an intensive migration if, or more likely when, you decide that you want to try out the hot new vector database."
    }
  ]
}