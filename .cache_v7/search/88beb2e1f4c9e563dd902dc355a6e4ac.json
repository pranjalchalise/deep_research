{
  "metadata": {
    "key": "search:general:10:How does LangGraph work and what are its key features?",
    "created": 1769904353.064171,
    "ttl": 86400
  },
  "data": [
    {
      "url": "https://www.datacamp.com/tutorial/langgraph-tutorial",
      "title": "LangGraph Tutorial: What Is LangGraph and How to Use It?",
      "snippet": "### Graph structure\n\nImagine your application as a directed graph. In LangGraph, each node represents an LLM agent, and the edges are the communication channels between these agents. This structure allows for clear and manageable workflows, where each agent performs specific tasks and passes information to other agents as needed.\n\n### State management\n\nOne of LangGraph's standout features is its automatic state management. This feature enables us to track and persist information across multiple interactions. As agents perform their tasks, the state is dynamically updated, ensuring the system maintains context and responds appropriately to new inputs.\n\n### Coordination [...] ### Scalability\n\nLangGraph is built to support the execution of large-scale multi-agent applications. Its robust architecture can handle a high volume of interactions and complex workflows, enabling the development of scalable systems that can grow with your needs. This makes it suitable for enterprise-level applications and scenarios where performance and reliability are critical.\n\n### Fault tolerance\n\nReliability is a core consideration in the design of LangGraph. The library includes mechanisms for gracefully handling errors, ensuring that your application can continue to operate even when individual agents encounter issues. This fault tolerance is essential for maintaining the stability and robustness of complex multi-agent systems. Peace of mind is just a feature away. [...] ### Chatbots\n\nLangGraph is ideal for developing sophisticated chatbots that can handle a wide array of user requests. By leveraging multiple LLM agents, these chatbots can process natural language queries, provide accurate responses, and seamlessly switch between different conversation topics. The ability to manage state and coordinate interactions ensures that the chatbot maintains context and delivers a coherent user experience.\n\n### Autonomous agents\n\nFor applications requiring autonomous decision-making, LangGraph enables the creation of agents that can perform tasks independently based on user inputs and predefined logic."
    },
    {
      "url": "https://www.ibm.com/think/topics/langgraph",
      "title": "What is LangGraph? - IBM",
      "snippet": "LangGraph is also built on several key technologies, including LangChain, a Python framework for building AI applications. LangChain includes a library for building and managing LLMs. LangGraph also uses the human-in-the-loop approach. By combining these technologies with a set of APIs and tools, LangGraph provides users with a versatile platform for developing AI solutions and workflows including chatbots, state graphs and other agent-based systems.\n\nDelve deeper into the world of LangGraph by exploring its key features, benefits and use cases. By the end of this article, you will have the knowledge and resources to take the next steps with LangGraph.\n\n## Key components of LangGraph [...] # What is LangGraph?\n\n## Authors\n\nBryan Clark \n\nSenior Technology Advocate\n\n## LangGraph overview\n\nLangGraph, created by LangChain, is an open source AI agent framework designed to build, deploy and manage complex generative AI agent workflows. It provides a set of tools and libraries that enable users to create, run and optimize large language models (LLMs) in a scalable and efficient manner. At its core, LangGraph uses the power of graph-based architectures to model and manage the intricate relationships between various components of an AI agent workflow. [...] LangGraph workflow\n\nLangGraph illuminates the processes within an AI workflow, allowing full transparency of the agent’s state. Within LangGraph, the “state” feature serves as a memory bank that records and tracks all the valuable information processed by the AI system. It’s similar to a digital notebook where the system captures and updates data as it moves through various stages of a workflow or graph analysis."
    },
    {
      "url": "https://docs.langchain.com/oss/python/langgraph/overview",
      "title": "LangGraph overview - Docs by LangChain",
      "snippet": "LangGraph provides low-level supporting infrastructure for _any_ long-running, stateful workflow or agent. LangGraph does not abstract prompts or architecture, and provides the following central benefits:\n   Durable execution: Build agents that persist through failures and can run for extended periods, resuming from where they left off.\n   Human-in-the-loop: Incorporate human oversight by inspecting and modifying agent state at any point.\n   Comprehensive memory: Create stateful agents with both short-term working memory for ongoing reasoning and long-term memory across sessions.\n   Debugging with LangSmith: Gain deep visibility into complex agent behavior with visualization tools that trace execution paths, capture state transitions, and provide detailed runtime metrics. [...] Trusted by companies shaping the future of agents— including Klarna, Replit, Elastic, and more— LangGraph is a low-level orchestration framework and runtime for building, managing, and deploying long-running, stateful agents.LangGraph is very low-level, and focused entirely on agent orchestration. Before using LangGraph, we recommend you familiarize yourself with some of the components used to build agents, starting with models and tools.We will commonly use LangChain components throughout the documentation to integrate models and tools, but you don’t need to use LangChain to use LangGraph. If you are just getting started with agents or want a higher-level abstraction, we recommend you use LangChain’s agents that provide pre-built architectures for common LLM and tool-calling [...] pre-built architectures for common LLM and tool-calling loops.LangGraph is focused on the underlying capabilities important for agent orchestration: durable execution, streaming, human-in-the-loop, and more."
    },
    {
      "url": "https://medium.com/@sachinsoni600517/understanding-langgraph-a-comprehensive-guide-to-building-llm-workflows-8c8c3629d8e0",
      "title": "Understanding LangGraph: A Comprehensive Guide to Building ...",
      "snippet": "So, what has LangGraph done here? It has understood your workflow and converted it into a graph structure, where each node is a subtask of your overall workflow. The best part? All these nodes are connected through edges. These edges tell us which task should be executed next after a particular node or task is completed.\n\n> In short, LangGraph provides a feature that allows you to represent any LLM workflow in the form of a flowchart and then execute it.\n\nOnce you’ve created this graph, what do you need to do? Simply provide input to the first node and trigger the workflow. Automatically, all the nodes will execute in the correct order, and your workflow will be completed. As stated, LangGraph is an orchestration framework for building intelligent, stateful, and multi-step LLM workflows. [...] The first observation you should have is that you can easily represent any such flow in the form of a graph. The second thing you’ll notice in this graph is two components: nodes and edges. Each node represents a single task in your workflow. That’s exactly what LangGraph does — when it creates a graph, each node represents a single task.\n\nNow, you might wonder what these nodes are behind the scenes. In LangGraph, every node is essentially a Python function — nothing more. If you know how to write Python functions, you can create these nodes. So, essentially, the graph in LangGraph is a set of Python functions interconnected with the help of edges. These edges tell us which node should execute next after a particular node is completed. [...] In simple words, LangGraph is nothing but an orchestration framework. What does that mean? It means that if you give LangGraph an LLM (Large Language Model) workflow to execute, it first tries to represent that workflow in the form of a graph.\n\nThe biggest highlight of this graph is that each node in it represents a task in your workflow. In LLM workflows, there can be various types of tasks. For example, one task could be calling an LLM, another could be invoking a tool, and a third could involve decision-making."
    },
    {
      "url": "https://medium.com/data-science/from-basics-to-advanced-exploring-langgraph-e8c1cf4db787",
      "title": "From Basics to Advanced: Exploring LangGraph - Medium",
      "snippet": "## LangGraph basics\n\nLangGraph is part of the LangChain ecosystem, so we will continue using well-known concepts like prompt templates, tools, etc. However, LangGraph brings a bunch of additional concepts. Let’s discuss them.\n\nLangGraph is created to define cyclical graphs. Graphs consist of the following elements:\n\n Nodes represent actual actions and can be either LLMs, agents or functions. Also, a special END node marks the end of execution.\n Edges connect nodes and determine the execution flow of your graph. There are basic edges that simply link one node to another and conditional edges that incorporate if-statements and additional logic. [...] In this article, I will explore LangGraph’s key features and capabilities, including multi-agent applications. We’ll build a system that can answer different types of questions and dive into how to implement a human-in-the-loop setup.\n\nIn the previous article, we tried using CrewAI, another popular framework for multi-agent systems. LangGraph, however, takes a different approach. While CrewAI is a high-level framework with many predefined features and ready-to-use components, LangGraph operates at a lower level, offering extensive customization and control.\n\nWith that introduction, let’s dive into the fundamental concepts of LangGraph.\n\n## LangGraph basics [...] Overall, I find LangGraph quite a powerful framework for building complex LLM applications:\n\n LangGraph is a low-level framework that offers extensive customisation options, allowing you to build precisely what you need.\n Since LangGraph is built on top of LangChain, it’s seamlessly integrated into its ecosystem, making it easy to leverage existing tools and components.\n\nHowever, there are areas where LangGrpah could be improved:"
    },
    {
      "url": "https://medium.com/@cplog/introduction-to-langgraph-a-beginners-guide-14f9be027141",
      "title": "Introduction to LangGraph: A Beginner's Guide - Medium",
      "snippet": "## Key Concepts\n\n Stateful Graph: LangGraph revolves around the concept of a stateful graph, where each node in the graph represents a step in your computation, and the graph maintains a state that is passed around and updated as the computation progresses.\n Nodes: Nodes are the building blocks of your LangGraph. Each node represents a function or a computation step. You define nodes to perform specific tasks, such as processing input, making decisions, or interacting with external APIs.\n Edges: Edges connect the nodes in your graph, defining the flow of computation. LangGraph supports conditional edges, allowing you to dynamically determine the next node to execute based on the current state of the graph.\n\n## A Simple Example [...] ## What is LangGraph?\n\nLangGraph is a library built on top of LangChain, designed to add cyclic computational capabilities to your LLM applications. While LangChain allows you to define chains of computation (Directed Acyclic Graphs or DAGs), LangGraph introduces the ability to add cycles, enabling more complex, agent-like behaviors where you can call an LLM in a loop, asking it what action to take next.\n\n## Key Concepts [...] Sitemap\n\nOpen in app\n\nSign in\n\nWrite\n\nSearch\n\nSign in\n\n# Introduction to LangGraph: A Beginner’s Guide\n\nCPlog\n\n3 min read\n\n·\n\nFeb 15, 2024\n\n--\n\nLangGraph is a powerful tool for building stateful, multi-actor applications with Large Language Models (LLMs). It extends the LangChain library, allowing you to coordinate multiple chains (or actors) across multiple steps of computation in a cyclic manner. In this article, we’ll introduce LangGraph, walk you through its basic concepts, and share some insights and common points of confusion for beginners.\n\n## What is LangGraph?"
    },
    {
      "url": "https://docs.langchain.com/oss/python/langgraph/functional-api",
      "title": "Functional API overview - Docs by LangChain",
      "snippet": "LangGraph APIs\n\nFunctional API\n\n# Functional API overview\n\nThe Functional API allows you to add LangGraph’s key features — persistence, memory, human-in-the-loop, and streaming — to your applications with minimal changes to your existing code. It is designed to integrate these features into existing code that may use standard language primitives for branching and control flow, such as `if` statements, `for` loops, and function calls. Unlike many data orchestration frameworks that require restructuring code into an explicit pipeline or DAG, the Functional API allows you to incorporate these capabilities without enforcing a rigid execution model. The Functional API uses two key building blocks: [...] To utilize features like human-in-the-loop, any randomness should be encapsulated inside of tasks. This guarantees that when execution is halted (e.g., for human in the loop) and then resumed, it will follow the same sequence of steps, even if task results are non-deterministic. LangGraph achieves this behavior by persisting task and subgraph results as they execute. A well-designed workflow ensures that resuming execution follows the same sequence of steps, allowing previously computed results to be retrieved correctly without having to re-execute them. This is particularly useful for long-running tasks or tasks with non-deterministic results, as it avoids repeating previously done work and allows resuming from essentially the same. While different runs of a workflow can produce [...] ## ​ Functional API vs. Graph API\n\nFor users who prefer a more declarative approach, LangGraph’s Graph API allows you to define workflows using a Graph paradigm. Both APIs share the same underlying runtime, so you can use them together in the same application. Here are some key differences:"
    },
    {
      "url": "https://www.langchain.com/langgraph",
      "title": "LangGraph - LangChain",
      "snippet": "“As Ally advances its exploration of Generative AI,\n\nImage 70\n\nSathish Muthukrishnan\n\nChief Information, Data and Digital Officer\n\nLangGraph FAQs\n\nHow is LangGraph different from other agent frameworks?\n\nOther agentic frameworks can work for simple, generic tasks but fall short for complex tasks bespoke to a company’s needs. LangGraph provides a more expressive framework to handle companies’ unique tasks without restricting users to a single black-box cognitive architecture.\n\nDoes LangGraph impact the performance of my app?\n\nLangGraph will not add any overhead to your code and is specifically designed with streaming workflows in mind.\n\nIs LangGraph open source? Is it free?\n\nYes. LangGraph is an MIT-licensed open-source library and is free to use. [...] ### Dynamic APIs for designing agent experience\n\nCraft personalized user experiences with APIs featuring long-term memory to recall information across conversation sessions. Track, update, and rewind your app's state for easy human steering and interaction. Kick off long-running background jobs for research-style or multi-step work.\n\n### Integrated developer experience\n\nSimplify prototyping, debugging, and sharing of agents in our visual LangGraph Studio. Deploy your application with 1-click deploy with our SaaS offering or within your own VPC. Then, monitor app performance with LangSmith.\n\n### Developers trust LangGraph to build reliable agents\n\nLangGraph helps teams of all sizes, across all industries, build reliable agents ready for production.\n\nHear how industry leaders use LangGraph [...] LangGraph\n\n\n\nImage 11\n\nImage 12\n\nImage 13\n\nImage 14\n\nImage 15\n\nImage 16\n\nImage 17\n\nImage 18\n\nImage 19\n\nImage 20%201.svg)\n\nImage 21\n\nImage 22\n\nImage 23\n\nImage 24\n\nImage 25\n\nImage 26\n\nImage 27\n\nImage 28\n\nImage 29\n\nImage 30%201.svg)\n\nImage 31\n\nImage 32\n\nImage 33\n\nImage 34\n\nImage 35\n\nImage 36\n\nImage 37\n\nImage 38\n\nImage 39\n\nImage 40%201.svg)\n\nImage 41\n\nImage 42\n\nImage 43\n\nImage 44\n\nImage 45\n\nImage 46\n\nImage 47\n\nImage 48\n\nImage 49\n\nControllable cognitive architecture for any task\n\nLangGraph's flexible framework supports diverse control flows – single agent, multi-agent, hierarchical, sequential – and robustly handles realistic, complex scenarios. \n\nEnsure reliability with easy-to-add moderation and quality loops that prevent agents from veering off course."
    },
    {
      "url": "https://www.youtube.com/watch?v=cUfLrn3TM3M",
      "title": "LangGraph Explained for Beginners - YouTube",
      "snippet": "a report based on the facts that are given within the state graph. So as you can see state graph plays a critical role in persisting information within the workflow and it's an important piece in orchestrating of the workflow and it's through this nature of graph part in langraph that provides additional features like loops conditional branching and state managements that helps you build a more complicated application than what lang chain might offer out of the box. As enterprise adoption of agentic software grows, tools like lane chain are a natural progression towards workflow automation and understanding when and how to use langraph can help you solve very interesting problems without having to write unnecessary code. Langraph really just helps you focus on architecture and problem [...] steps. So in our case we need to create nodes for the following tasks. First a note to search and gather sources. Second a note to scrap and clean content. Third, a node to evaluate trustworthiness using an LLM. Four, a node to extract factual statements from the sources. And five, a node that generates a report. And once all these nodes and edges are configured and compiled, Lang graph will orchestrate them by executing them based on how it's configured. So for a deep research assistant, the graph will look something like this, where you have the starting node that serves as the entry point and all the nodes and edges that do individual tasks and finally an end node that terminates the workflow. Now what makes lang graph special is what's called state graph meaning they all have a shared [...] software development, you not only have to write code that first fetches a set of links using a search engine API. Second, loop through these links manually. Third, scrape the content and feed it to a large language model. Four, evaluate the score for each source. And five, check the score and only use sources that surpasses 75%. And six, analyze and store these facts into a report. You not only have to write all of these code individually but also orchestrate the sequence of how these code will run in order to maintain them. Now with lang graph the steps look a little bit more streamlined. The entire process can be run using a graph where each node is responsible for a very specific task and each edge determines the flow or execution steps. So in our case we need to create nodes for the"
    },
    {
      "url": "https://docs.aws.amazon.com/prescriptive-guidance/latest/agentic-ai-frameworks/langchain-langgraph.html",
      "title": "LangChain and LangGraph - AWS Prescriptive Guidance",
      "snippet": "LangChain and LangGraph - AWS Prescriptive Guidance\n\nDocumentationAWS Prescriptive GuidanceAgentic AI frameworks, platforms, protocols, and tools on AWS\n\nKey features of LangChain and LangGraphWhen to use LangChain and LangGraphImplementation approach for LangChain and LangGraphReal-world example of LangChain and LangGraph\n\n# LangChain and LangGraph\n\nLangChain is one of the most established frameworks in the agentic AI ecosystem. LangGraph extends its capabilities to support complex, stateful agent workflows as described in the LangChain Blog. Together, they provide a comprehensive solution for building sophisticated autonomous AI agents with rich orchestration capabilities for independent operation.\n\n## Key features of LangChain and LangGraph [...] ## Key features of LangChain and LangGraph\n\nLangChain and LangGraph include the following key features: [...] ## Implementation approach for LangChain and LangGraph\n\nLangChain and LangGraph provide a structured implementation approach for business stakeholders, as detailed in the LangGraph documentation. The framework enables organizations to:\n\n Define sophisticated workflow graphs that represent business processes.\n Create multi-step reasoning patterns with decision points and conditional logic.\n Integrate multimodal processing capabilities for handling diverse data types.\n Implement quality control through built-in review and validation mechanisms.\n\nThis graph-based approach allows business teams to model complex decision processes as autonomous workflows. Teams have clear visibility into each step of the reasoning process and the ability to audit decision paths."
    }
  ]
}